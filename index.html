<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="description" content="Sistema GPS con Nube de Puntos Potree" />
    <meta name="author" content="" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>Sistema GPS Potree</title>

    <link rel="stylesheet" type="text/css" href="./libs/potree/potree.css" />
    <link
      rel="stylesheet"
      type="text/css"
      href="./libs/jquery-ui/jquery-ui.min.css"
    />
    <link rel="stylesheet" type="text/css" href="./libs/openlayers3/ol.css" />
    <link rel="stylesheet" type="text/" href="./libs/spectrum/spectrum.css" />
    <link
      rel="stylesheet"
      type="text/css"
      href="./libs/jstree/themes/mixed/style.css"
    />

    <script src="https://sdk.amazonaws.com/js/aws-sdk-2.1480.0.min.js"></script>

    <style>
      .coordinate-display {
        margin-top: 10px;
        padding: 5px;
        background: rgba(0, 0, 0, 0.1);
        border-radius: 3px;
      }

      #debug-panel {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        padding: 10px;
        border-radius: 5px;
        z-index: 1000;
        width: 400px;
        max-height: 200px;
        overflow-y: auto;
        font-family: monospace;
        font-size: 12px;
      }

      .marker-label {
        color: white;
        background-color: rgba(0, 0, 0, 0.6);
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 12px;
        font-weight: bold;
        white-space: nowrap;
        pointer-events: none;
      }

      #simple-controls {
        position: absolute;
        bottom: 30px;
        right: 10px;
        background: rgba(255, 255, 255, 0.8);
        padding: 10px;
        border-radius: 5px;
        z-index: 1000;
        display: flex;
        flex-direction: column;
      }

      #simple-controls button {
        margin: 5px;
        padding: 8px;
        background-color: #4caf50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        width: 180px;
      }

      #simple-controls button:hover {
        background-color: #45a049;
      }

      #left-toolbar {
        position: absolute;
        right: 10px;
        left: auto;
        top: 50%;
        transform: translateY(-50%);
        background: rgba(255, 255, 255, 0.8);
        padding: 10px;
        border-radius: 5px;
        z-index: 1000;
        display: flex;
        flex-direction: column;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      }

      #left-toolbar button {
        margin: 5px 0;
        padding: 8px;
        background-color: #4caf50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        width: 40px;
        height: 40px;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      #left-toolbar button:hover {
        background-color: #45a049;
      }

      #left-toolbar button i {
        font-size: 20px;
      }

      /*********************************************** Iconos de Potree */
      /* Mejorar la carga de iconos con rutas absolutas */
      .potree_full_extent_icon::before {
        content: "";
        display: inline-block;
        width: 24px;
        height: 24px;
        background-image: url("./libs/potree/resources/icons/helicopter_controls.svg");
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
      }

      .potree_move_icon::before {
        content: "";
        display: inline-block;
        width: 24px;
        height: 24px;
        background-image: url("./libs/potree/resources/icons/arrow_right.svg");
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
      }
      /*********************************************** Iconos de Potree */

      /* Paso 5: Añade estilos para mejorar la visualización de los botones */
      #left-toolbar button {
        position: relative;
        overflow: visible;
      }

      #left-toolbar button i {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 24px;
        height: 24px;
      }

      /* Eliminar completamente el panel de Potree */
      #potree_sidebar_container,
      .potree_container .sidebar,
      .potree_menu_toggle,
      .potree_logo,
      .potree_menu_buttons,
      .potree_tool_icon,
      #potree_sidebar_container * {
        display: none !important;
        width: 0 !important;
        height: 0 !important;
        visibility: hidden !important;
        opacity: 0 !important;
        pointer-events: none !important;
        overflow: hidden !important;
        position: absolute !important;
        left: -9999px !important;
      }

      /* Asegurarse que no queden rastros del panel */
      .potree_container {
        position: absolute;
        width: 100%;
        height: 100%;
        left: 0px !important;
        right: 0px !important;
        pointer-events: auto;
      }

      #potree_render_area {
        left: 0px !important;
        right: 0px !important;
        width: 100% !important;
        position: absolute;
      }

      /* Estilos para el nuevo panel desplegable */
      #points-panel {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 5px;
        z-index: 1001;
        width: 320px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        transition: transform 0.3s ease;
        max-height: 80vh;
        display: flex;
        flex-direction: column;
      }

      #points-panel-header {
        padding: 10px;
        background: #4caf50;
        color: white;
        border-radius: 5px 5px 0 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
      }

      #points-panel-content {
        padding: 0;
        overflow-y: auto;
        max-height: calc(80vh - 40px);
      }

      .point-item {
        padding: 10px;
        border-bottom: 1px solid #ddd;
        display: flex;
        align-items: center;
      }

      .point-item:last-child {
        border-bottom: none;
      }

      .point-icon {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background-color: #ff0000;
        margin-right: 10px;
        flex-shrink: 0;
      }

      .point-details {
        flex-grow: 1;
      }

      .point-title {
        font-weight: bold;
        margin-bottom: 5px;
      }

      .point-coords {
        font-size: 12px;
        color: #666;
        font-family: monospace;
      }

      .panel-collapsed {
        transform: translateX(-290px);
      }

      .toggle-btn {
        background: none;
        border: none;
        cursor: pointer;
        font-size: 18px;
        color: white;
        padding: 0;
      }

      .point-item {
        cursor: pointer;
        transition: background-color 0.3s, box-shadow 0.3s;
      }

      .point-item:hover {
        background-color: rgba(76, 175, 80, 0.1); /* Verde claro translúcido */
        box-shadow: 0 0 8px rgba(76, 175, 80, 0.3); /* Sombra verde tenue */
        border-radius: 5px;
      }
    </style>
  </head>

  <body>
    <script src="./libs/jquery/jquery-3.1.1.min.js"></script>
    <script src="./libs/spectrum/spectrum.js"></script>
    <script src="./libs/jquery-ui/jquery-ui.min.js"></script>
    <script src="./libs/three.js/build/three.min.js"></script>
    <script src="./libs/three.js/extra/lines.js"></script>
    <script src="./libs/other/BinaryHeap.js"></script>
    <script src="./libs/tween/tween.min.js"></script>
    <script src="./libs/d3/d3.js"></script>
    <script src="./libs/proj4/proj4.js"></script>
    <script src="./libs/openlayers3/ol.js"></script>
    <script src="./libs/i18next/i18next.js"></script>
    <script src="./libs/jstree/jstree.js"></script>
    <script src="./libs/potree/potree.js"></script>
    <script src="./libs/plasio/js/laslaz.js"></script>

    <div
      class="potree_container"
      style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px"
    >
      <div
        id="potree_render_area"
        style="
          background-image: url('./libs/potree/resources/images/background.jpg');
        "
      ></div>
      <div
        id="potree_sidebar_container"
        style="
          display: none !important;
          width: 0;
          height: 0;
          overflow: hidden;
          position: absolute;
        "
      ></div>

      <div id="left-toolbar">
        <button id="btn-full-extent" title="Full Extent">
          <i class="potree_full_extent_icon"></i>
        </button>
        <button id="btn-move-5m" title="Mover 5m al Este">
          <i class="potree_move_icon"></i>
        </button>
      </div>
    </div>

    <!-- Eliminar completamente el panel de depuración en lugar de ocultarlo -->
    <div
      id="debug-panel"
      style="
        display: none !important;
        width: 0;
        height: 0;
        overflow: hidden;
        position: absolute;
        visibility: hidden;
        opacity: 0;
      "
    >
      <!-- El contenido se mantendrá invisible y completamente eliminado del flujo del documento -->
    </div>

    <!-- Nuevo panel desplegable para puntos -->
    <div id="points-panel">
      <div id="points-panel-header">
        <span>Puntos GPS</span>
        <button class="toggle-btn" id="toggle-panel">≪</button>
      </div>
      <div id="points-panel-content">
        <!-- Los puntos se agregarán dinámicamente aquí -->
      </div>
    </div>

    <script>
      // Función para mostrar mensajes de depuración
      function debug(message) {
        // Solo envía a la consola, no al panel visual
        console.log(`[DEBUG] ${message}`);
      }

      debug("Iniciando aplicación...");

      // Inicializar el visor Potree
      window.viewer = new Potree.Viewer(
        document.getElementById("potree_render_area")
      );

      // Configuración del visor
      viewer.setEDLEnabled(true);
      viewer.setFOV(60);
      viewer.setPointBudget(2_500_000);
      viewer.setBackground("gradient");
      viewer.loadSettingsFromURL();

      debug(
        "Visor Potree inicializado correctamente con densidad máxima fija de 2,500,000 puntos"
      );

      // Variables globales
      let gpsMarker = null;

      // MATRIZ DE COORDENADAS GPS PREDEFINIDAS (simula datos desde AWS)
      const userLocations = [
        { id: "3025064629", lat: null, lon: null, alt: null, color: "#ff0000" },
        { id: "4testing", lat: null, lon: null, alt: null, color: "#00ff00" },
        { id: "3023456789", lat: null, lon: null, alt: null, color: "#0000ff" },
      ];

      // Mapa de ID a marcador (para actualización futura)
      const userMarkers = {};

      let annotations = null;
      let pointcloud = null;
      let labelDiv = null;
      let cloudLoaded = false;
      let referenceMarker = null;
      let cameraMoving = false;
      let gpsBlinkInterval = null;
      let gpsDB = null;

      //-------------------------------------------------------------

      // Función para convertir coordenadas en formato DMS (grados, minutos, segundos) a decimal
      function dmsToDecimal(degrees, minutes, seconds, direction) {
        let decimal = degrees + minutes / 60 + seconds / 3600;
        // Si la dirección es Sur (S) o Oeste (W/O), el valor debe ser negativo
        if (direction === "S" || direction === "W" || direction === "O") {
          decimal = -decimal;
        }
        return decimal;
      }

      //--------------------------------------------------------------

      // Función para convertir coordenadas decimales a formato DMS (grados, minutos, segundos)
      function decimalToDMS(decimal, isLatitude) {
        // Asegurar que el valor es positivo para el cálculo
        const absDecimal = Math.abs(decimal);

        // Calcular grados (parte entera)
        const degrees = Math.floor(absDecimal);

        // Calcular minutos (parte decimal * 60, y luego tomar la parte entera)
        const minutesDecimal = (absDecimal - degrees) * 60;
        const minutes = Math.floor(minutesDecimal);

        // Calcular segundos (parte decimal de los minutos * 60)
        const seconds = ((minutesDecimal - minutes) * 60).toFixed(2);

        // Determinar la dirección (N/S para latitud, E/O para longitud)
        let direction;
        if (isLatitude) {
          direction = decimal >= 0 ? "N" : "S";
        } else {
          direction = decimal >= 0 ? "E" : "O";
        }

        // Formatear el resultado
        return `${degrees}° ${minutes}' ${seconds}" ${direction}`;
      }

      window.awsConfig = {
        region: "us-east-1",
        accessKeyId: "AKIAZCRUSKBBWDBPX4PN",
        secretAccessKey: "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"
      };

      // Punto de referencia conocido para la conversión (aleta de tiburón)
      const referencePoint = {
        // Coordenadas GPS en formato crudo
        gpsRaw: {
          lat: { degrees: 10, minutes: 59, seconds: 54.22, direction: "N" },
          lon: { degrees: 74, minutes: 46, seconds: 21.87, direction: "O" },
          alt: 3, // 3 metros
        },
        // Coordenadas GPS (latitud, longitud, altitud) en decimal
        gps: {
          lat: null, // Se calculará a continuación
          lon: null, // Se calculará a continuación
          alt: 3, // 3 metros
        },
        // Coordenadas en la nube Potree
        cloud: {
          x: 524823.59,
          y: 1215810.79,
          z: 31.98,
        },
      };

      // Convertir coordenadas crudas a decimal
      referencePoint.gps.lat = dmsToDecimal(
        referencePoint.gpsRaw.lat.degrees,
        referencePoint.gpsRaw.lat.minutes,
        referencePoint.gpsRaw.lat.seconds,
        referencePoint.gpsRaw.lat.direction
      );

      referencePoint.gps.lon = dmsToDecimal(
        referencePoint.gpsRaw.lon.degrees,
        referencePoint.gpsRaw.lon.minutes,
        referencePoint.gpsRaw.lon.seconds,
        referencePoint.gpsRaw.lon.direction
      );

      // Agregar mensaje de depuración para confirmar la conversión
      debug(`Punto de referencia (convertido): 
            GPS: (${referencePoint.gps.lat}, ${referencePoint.gps.lon}, ${referencePoint.gps.alt})
            Nube: (${referencePoint.cloud.x}, ${referencePoint.cloud.y}, ${referencePoint.cloud.z})`);

      //----------------------------------------------------------------------

      debug(`Punto de referencia configurado: 
            GPS: (${referencePoint.gps.lat}, ${referencePoint.gps.lon}, ${referencePoint.gps.alt})
            Nube: (${referencePoint.cloud.x}, ${referencePoint.cloud.y}, ${referencePoint.cloud.z})`);

      //----------------------------------------------------------------------------

      // Función para convertir coordenadas GPS a coordenadas de la nube
      function convertGPSToCloudCoords(lat, lon, alt) {
        debug(
          `Convirtiendo coordenadas GPS (${lat}, ${lon}, ${alt}) a coordenadas de nube...`
        );

        try {
          // Calculamos la diferencia en grados
          const dLat = lat - referencePoint.gps.lat;
          const dLon = lon - referencePoint.gps.lon;
          const dAlt = alt - referencePoint.gps.alt;

          // Conversión aproximada: 1 grado de latitud ≈ 111.32 km = 111320 metros
          // En el Ecuador, 1 grado de longitud ≈ 111.32 km, pero varía con la latitud
          // Factor de corrección para longitud: cos(latitud en radianes)
          const lonCorrectionFactor = Math.cos(
            (referencePoint.gps.lat * Math.PI) / 180
          );

          // Convertimos diferencias en grados a metros (aproximado)
          const dY = dLat * 111320; // Norte-Sur
          const dX = dLon * 111320 * lonCorrectionFactor; // Este-Oeste

          // Aplicamos la diferencia a las coordenadas de la nube
          const cloudX = referencePoint.cloud.x + dX;
          const cloudY = referencePoint.cloud.y + dY;
          const cloudZ = referencePoint.cloud.z + dAlt;

          debug(
            `Coordenadas convertidas: (${cloudX.toFixed(2)}, ${cloudY.toFixed(
              2
            )}, ${cloudZ.toFixed(2)})`
          );

          return {
            x: cloudX,
            y: cloudY,
            z: cloudZ,
          };
        } catch (error) {
          debug(`ERROR en la conversión de coordenadas: ${error.message}`);
          console.error("Error en la conversión de coordenadas:", error);
          return null;
        }
      }

      //-------------------------------------------------------------------------------

      // Función para crear/actualizar el marcador en la nube
      function updateMarker(x, y, z, lat = null, lon = null, alt = null) {
        debug(
          `Intentando crear marcador en (${x.toFixed(2)}, ${y.toFixed(
            2
          )}, ${z.toFixed(2)})...`
        );

        // Si no se proporcionan coordenadas GPS, intentar calcularlas inversamente (aproximación)
        if (lat === null || lon === null || alt === null) {
          // Este es un cálculo inverso aproximado
          const dX = x - referencePoint.cloud.x;
          const dY = y - referencePoint.cloud.y;
          const dZ = z - referencePoint.cloud.z;

          // Factor de corrección para longitud: cos(latitud en radianes)
          const lonCorrectionFactor = Math.cos(
            (referencePoint.gps.lat * Math.PI) / 180
          );

          // Convertir diferencias en metros a grados (aproximado)
          const dLat = dY / 111320;
          const dLon = dX / (111320 * lonCorrectionFactor);

          lat = referencePoint.gps.lat + dLat;
          lon = referencePoint.gps.lon + dLon;
          alt = referencePoint.gps.alt + dZ;
        }

        // Resto del código de la función updateMarker...

        try {
          // Eliminar marcador anterior si existe
          if (gpsMarker) {
            viewer.scene.scene.remove(gpsMarker);
            debug("Marcador anterior eliminado");
          }

          // Iniciar efecto de parpadeo
          if (gpsBlinkInterval) {
            clearInterval(gpsBlinkInterval);
          }

          let visible = true;
          gpsBlinkInterval = setInterval(() => {
            if (gpsMarker && gpsMarker.material) {
              gpsMarker.material.opacity = visible ? 0.0 : 0.8;
              gpsMarker.material.needsUpdate = true;
              visible = !visible;
            }
          }, 500); // 500ms = 0.5 segundos

          // Eliminar etiqueta anterior si existe
          if (labelDiv) {
            const container = document.getElementById("potree_render_area");
            container.removeChild(labelDiv);
            labelDiv = null;
            debug("Etiqueta anterior eliminada");
          }

          // Crear nuevo marcador (esfera roja)
          const sphereGeometry = new THREE.SphereGeometry(2, 32, 32);
          const sphereMaterial = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            opacity: 0.8,
            transparent: true,
          });
          gpsMarker = new THREE.Mesh(sphereGeometry, sphereMaterial);
          gpsMarker.position.set(x, y, z);
          viewer.scene.scene.add(gpsMarker);
          debug("Marcador (esfera) creado y añadido a la escena");

          // Crear etiqueta
          labelDiv = document.createElement("div");
          labelDiv.className = "marker-label";
          labelDiv.style.position = "absolute";
          labelDiv.style.padding = "10px";
          labelDiv.style.background = "rgba(0, 0, 0, 0.7)";
          labelDiv.style.color = "white";
          labelDiv.style.borderRadius = "5px";
          labelDiv.style.pointerEvents = "none";
          labelDiv.style.zIndex = "1000";
          labelDiv.innerHTML = `
                    <span style="font-weight: bold;">Posición GPS</span><br>
                    X: ${x.toFixed(2)}, Y: ${y.toFixed(2)}, Z: ${z.toFixed(2)}
                `;

          // Añadir etiqueta al contenedor
          const container = document.getElementById("potree_render_area");
          container.appendChild(labelDiv);

          // Actualizar posición de la etiqueta en cada frame
          function updateLabelPosition() {
            if (!gpsMarker) return;

            // Verificar si la cámara y el marcador existen
            const camera = viewer.scene.getActiveCamera();
            if (!camera) return;

            const screenPos = gpsMarker.position.clone().project(camera);

            // Verificar si el punto está delante de la cámara (z < 1)
            if (screenPos.z < 1) {
              // Convertir a coordenadas de pantalla
              const x = ((screenPos.x + 1) * container.clientWidth) / 2;
              const y = ((-screenPos.y + 1) * container.clientHeight) / 2;

              // Actualizar posición de la etiqueta
              labelDiv.style.left = `${x}px`;
              labelDiv.style.top = `${y - 50}px`; // Desplazar un poco arriba
              labelDiv.style.display = "block";
            } else {
              // Ocultar la etiqueta si está detrás de la cámara
              labelDiv.style.display = "none";
            }

            requestAnimationFrame(updateLabelPosition);
          }

          // Iniciar la actualización
          updateLabelPosition();

          // Mostrar las coordenadas convertidas en la interfaz
          document.getElementById("cloud-coords").textContent = `X: ${x.toFixed(
            2
          )}, Y: ${y.toFixed(2)}, Z: ${z.toFixed(2)}`;

          // Mover la cámara de forma suave
          moveCamera(x, y, z);

          debug("Coordenadas convertidas mostradas en la interfaz");
        } catch (error) {
          debug(`ERROR al crear marcador: ${error.message}`);
          console.error("Error al crear marcador:", error);
        }

        // Actualizar el panel desplegable con las coordenadas del marcador
        updatePointPanel(x, y, z, lat, lon, alt);
      }

      //

      function createUserMarker(x, y, z, user) {
        debug(
          `Creando marcador para ${user.id} en (${x.toFixed(2)}, ${y.toFixed(
            2
          )}, ${z.toFixed(2)})`
        );

        const geometry = new THREE.SphereGeometry(2, 32, 32);
        const material = new THREE.MeshBasicMaterial({
          color: new THREE.Color(user.color),
          opacity: 0.8,
          transparent: true,
        });
        const marker = new THREE.Mesh(geometry, material);
        marker.position.set(x, y, z);
        viewer.scene.scene.add(marker);

        // Parpadeo
        let visible = true;
        setInterval(() => {
          if (marker.material) {
            marker.material.opacity = visible ? 0.0 : 0.8;
            marker.material.needsUpdate = true;
            visible = !visible;
          }
        }, 500);

        // ✅ AGREGAR AL PANEL LATERAL solo si hay marcador
        const panel = document.getElementById("points-panel-content");
        const div = document.createElement("div");
        div.className = "point-item";
        div.id = `user-panel-${user.id}`; // útil si luego quieres eliminarlo dinámicamente
        div.innerHTML = `
                <div class="point-icon" style="background-color: ${
                  user.color
                };"></div>
                <div class="point-details">
                    <div class="point-title">Usuario ${user.id}</div>
                    <div class="point-coords">
                        Lat: ${decimalToDMS(user.lat, true)}<br>
                        Lon: ${decimalToDMS(user.lon, false)}<br>
                        Alt: ${user.alt.toFixed(2)} m<br>
                        ${
                          user.custom && Object.keys(user.custom).length > 0
                            ? `<small>Custom: ${JSON.stringify(user.custom)}</small><br>`
                            : ""
                        }
                        <small>Nube: X=${x.toFixed(2)}, Y=${y.toFixed(
          2
        )}, Z=${z.toFixed(2)}</small>
                    </div>
                </div>
            `;
        div.addEventListener("click", () => {
          if (!cameraMoving) moveCamera(x, y, z);
        });
        panel.appendChild(div);

        return marker;
      }

      //

      function actualizarUsuariosDesdeAWS(positions) {
        const idsRecibidos = new Set();

        positions.forEach((datos) => {
          const user = userLocations.find((u) => u.id === datos.id);
          if (user) {
            const isNew =
              user.lat !== datos.lat ||
              user.lon !== datos.lon ||
              user.alt !== datos.alt;

            user.lat = datos.lat;
            user.lon = datos.lon;
            user.alt = datos.alt;
            user.custom = datos.custom || {};
            idsRecibidos.add(user.id);

            const cloud = convertGPSToCloudCoords(user.lat, user.lon, user.alt);
            if (!cloud) return;

            // Crear o actualizar marcador
            if (userMarkers[user.id]) {
              userMarkers[user.id].position.set(cloud.x, cloud.y, cloud.z);
            } else {
              const marker = createUserMarker(cloud.x, cloud.y, cloud.z, user);
              userMarkers[user.id] = marker;
            }

            // ✅ Actualizar cámara si el punto se movió
            if (isNew && !cameraMoving) {
              moveCamera(cloud.x, cloud.y, cloud.z);
            }

            // ✅ Actualizar panel lateral
            const oldPanel = document.getElementById(`user-panel-${user.id}`);
            if (oldPanel) oldPanel.remove();

            const panel = document.getElementById("points-panel-content");
            const div = document.createElement("div");
            div.className = "point-item";
            div.id = `user-panel-${user.id}`;
            div.innerHTML = `
                    <div class="point-icon" style="background-color: ${
                      user.color
                    };"></div>
                    <div class="point-details">
                    <div class="point-title">Usuario ${user.id}</div>
                    <div class="point-coords">
                        Lat: ${decimalToDMS(user.lat, true)}<br>
                        Lon: ${decimalToDMS(user.lon, false)}<br>
                        Alt: ${user.alt.toFixed(2)} m<br>
                        <small>Nube: X=${cloud.x.toFixed(
                          2
                        )}, Y=${cloud.y.toFixed(2)}, Z=${cloud.z.toFixed(
              2
            )}</small>
                    </div>
                    </div>
                `;
            div.addEventListener("click", () => {
              if (!cameraMoving) moveCamera(cloud.x, cloud.y, cloud.z);
            });
            panel.appendChild(div);
          }
        });

        // Eliminar usuarios no incluidos en esta actualización
        userLocations.forEach((user) => {
          if (!idsRecibidos.has(user.id) && userMarkers[user.id]) {
            viewer.scene.scene.remove(userMarkers[user.id]);
            delete userMarkers[user.id];
            const panel = document.getElementById(`user-panel-${user.id}`);
            if (panel) panel.remove();
            user.lat = user.lon = user.alt = null;
          }
        });
      }

      //
      async function cargarDesdeAWS() {
        if (!gpsDB) return;

        try {
          const posiciones = await gpsDB.getRecentPositions(50);
          console.log("Datos recibidos de AWS:", posiciones); // 👈 Agrega esto

          const datosFormateados = posiciones.map((p) => ({
            id: p.id,
            lat: p.latitude,
            lon: p.longitude,
            alt: p.altitude,
          }));

          actualizarUsuariosDesdeAWS(datosFormateados);
        } catch (err) {
          console.error("Error al cargar posiciones desde AWS:", err);
        }
      }

      // Función para actualizar el panel desplegable con los datos del punto
      function updatePointPanel(x, y, z, lat, lon, alt) {
        debug("Actualizando panel de puntos GPS...");

        try {
          const pointContent = document.getElementById("points-panel-content");

          // Convertir coordenadas decimales a formato DMS
          const latDMS = decimalToDMS(lat, true);
          const lonDMS = decimalToDMS(lon, false);

          // Crear o actualizar el contenido del panel
          pointContent.innerHTML = `
                    <div class="point-item" style="cursor: pointer;" title="Centrar cámara en este punto">
                        <div class="point-icon"></div>
                        <div class="point-details">
                            <div class="point-title">Posición GPS</div>
                            <div class="point-coords">
                                Lat: ${latDMS}<br>
                                Lon: ${lonDMS}<br>
                                Alt: ${alt.toFixed(2)} m<br>
                                <small>Nube: X=${x.toFixed(2)}, Y=${y.toFixed(
            2
          )}, Z=${z.toFixed(2)}</small>
                            </div>
                        </div>
                    </div>
                `;

          const pointItem = pointContent.querySelector(".point-item");
          pointItem.addEventListener("click", () => {
            debug("Panel clickeado, centrando cámara en punto GPS...");
            if (!cameraMoving) {
              moveCamera(x, y, z);
            } else {
              alert("La cámara ya se está moviendo. Por favor espere...");
            }
          });

          debug("Panel de puntos GPS actualizado");
        } catch (error) {
          debug(`ERROR al actualizar panel de puntos: ${error.message}`);
          console.error("Error al actualizar panel de puntos:", error);
        }
      }

      // Función para mover la cámara de forma suave con pasos intermedios
      function moveCamera(x, y, z) {
        if (!pointcloud || cameraMoving) return;

        debug(
          `Moviendo cámara hacia el punto (${x.toFixed(2)}, ${y.toFixed(
            2
          )}, ${z.toFixed(2)})...`
        );
        cameraMoving = true;

        try {
          const camera = viewer.scene.getActiveCamera();
          const currentPos = camera.position.clone();
          const currentTarget = viewer.scene.view.getPivot().clone();

          const newTarget = new THREE.Vector3(x, y, z);
          const direction = new THREE.Vector3()
            .subVectors(currentPos, currentTarget)
            .normalize();
          const distancia = 50;
          const newPos = new THREE.Vector3(
            x + direction.x * distancia,
            y + direction.y * distancia,
            z + direction.z * distancia + 20
          );

          const numSteps = 20;
          const duration = 2000;
          const stepInterval = duration / numSteps;
          let currentStep = 0;

          function moveStep() {
            if (currentStep >= numSteps) {
              cameraMoving = false;
              debug("Movimiento de cámara completado");
              if (pointcloud) {
                pointcloud.visible = true;

                const updateLOD = () => {
                  viewer.scene.dispatchEvent({ type: "pointclouds_loaded" });
                  viewer.scene.dispatchEvent({ type: "update" });
                };

                updateLOD();
                setTimeout(updateLOD, 500);
                setTimeout(updateLOD, 1000);
              }
              return;
            }

            const progress = (currentStep + 1) / numSteps;
            const lerpPos = new THREE.Vector3().lerpVectors(
              currentPos,
              newPos,
              progress
            );
            const lerpTarget = new THREE.Vector3().lerpVectors(
              currentTarget,
              newTarget,
              progress
            );

            viewer.scene.view.setView(
              [lerpPos.x, lerpPos.y, lerpPos.z],
              [lerpTarget.x, lerpTarget.y, lerpTarget.z]
            );

            if (pointcloud && !pointcloud.visible) {
              pointcloud.visible = true;
              debug(
                "Forzando visibilidad durante movimiento, paso " + currentStep
              );
            }

            currentStep++;
            setTimeout(moveStep, stepInterval);
          }

          moveStep();
        } catch (error) {
          cameraMoving = false;
          debug(`ERROR al mover la cámara: ${error.message}`);
          console.error("Error al mover la cámara:", error);
        }
      }

      //-----------------------------------------------------------------------------

      class GPSDatabase {
        constructor(tableName = "locations") {
          if (!window.awsConfig) {
            throw new Error("awsConfig no está definido.");
          }

          AWS.config.update({
            region: window.awsConfig.region,
            accessKeyId: window.awsConfig.accessKeyId,
            secretAccessKey: window.awsConfig.secretAccessKey,
          });

          this.tableName = tableName;
          this.docClient = new AWS.DynamoDB.DocumentClient();
        }
        async getRecentPositions(count = 50) {
          const params = {
            TableName: this.tableName,
          };

          const data = await this.docClient.scan(params).promise();
          console.log("Contenido crudo de AWS:", data.Items);

          const resultadosValidos = data.Items.filter(
            (item) =>
              typeof item.deviceId === "string" &&
              typeof item.timestamp === "number" &&
              typeof item.latitude === "number" &&
              typeof item.longitude === "number" &&
              typeof item.altitude === "number"
          );

          // Agrupar por deviceId y obtener solo el de mayor timestamp
          const registrosPorDispositivo = {};
          for (const item of resultadosValidos) {
            const id = item.deviceId;
            if (
              !registrosPorDispositivo[id] ||
              item.timestamp > registrosPorDispositivo[id].timestamp
            ) {
              registrosPorDispositivo[id] = item;
            }
          }

          // Transformar en lista y forzar el formato que usas en validatePosition()
          return Object.entries(registrosPorDispositivo).map(([id, item]) => ({
            id: id.toString(),  // Esto asegura que sea string como espera validatePosition
            timestamp: item.timestamp,
            latitude: item.latitude,
            longitude: item.longitude,
            altitude: item.altitude,
            custom: item.custom || {}, // Aquí pasamos custom para mostrarlo en el panel
          }));
        }
      }

      // Crear un marcador para el punto de referencia
      function createReferenceMarker() {
        if (!cloudLoaded) return;

        debug("Creando marcador para el punto de referencia...");

        try {
          // Crear un cubo para el punto de referencia
          const cubeGeometry = new THREE.BoxGeometry(3, 3, 3);
          const cubeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
          referenceMarker = new THREE.Mesh(cubeGeometry, cubeMaterial);

          // Colocar en el punto de referencia exacto
          referenceMarker.position.set(
            referencePoint.cloud.x,
            referencePoint.cloud.y,
            referencePoint.cloud.z
          );

          // Añadir a la escena
          viewer.scene.scene.add(referenceMarker);
          debug(
            "Marcador de referencia creado (cubo verde en aleta de tiburón)"
          );
        } catch (error) {
          debug(`ERROR al crear marcador de referencia: ${error.message}`);
          console.error("Error al crear marcador de referencia:", error);
        }
      }

      //-------------------------------------------------------------------------------

      viewer.loadGUI(() => {
        debug("GUI de Potree cargada");
        viewer.setLanguage("en");

        // Ocultar sidebar al inicio
        viewer.toggleSidebar();
        debug("Sidebar ocultada");

        // Ocultar todas las herramientas excepto las especificadas
        const toolsToKeep = ["full_extent"];

        // Recorrer todas las herramientas y ocultar las que no están en la lista
        for (let key in viewer.measuringTool) {
          if (!toolsToKeep.includes(key)) {
            try {
              viewer.measuringTool[key].element.style.display = "none";
            } catch (e) {
              debug(`No se pudo ocultar la herramienta: ${key}`);
            }
          }
        }

        // También intentar ocultar elementos del menú que no necesitamos
        setTimeout(() => {
          try {
            // Ocultar elementos de menú no necesarios
            document
              .querySelectorAll(
                "#potree_sidebar_container .potree_menu_buttons li"
              )
              .forEach((item) => {
                if (!item.classList.contains("full_extent")) {
                  item.style.display = "none";
                }
              });
            debug("Herramientas innecesarias ocultadas");
          } catch (e) {
            debug(`Error al ocultar elementos de menú: ${e.message}`);
          }
        }, 1000);

        // Ocultar completamente el sidebar de Potree
        document.getElementById("potree_sidebar_container").style.display =
          "none";
        debug("Panel lateral de Potree completamente ocultado");
      });

      //----------------------------------M1.1---------------------------------------------------

      Potree.loadPointCloud("pointclouds/Nube1/cloud.js", "Nube1", (e) => {
        debug("Cargando nube de puntos...");
        pointcloud = e.pointcloud;
        let material = pointcloud.material;
        viewer.scene.addPointCloud(pointcloud);

        debug("Nube de puntos añadida a la escena");

        // Determinar la altura mínima de la nube
        try {
          const boundingBox = pointcloud.boundingBox;
          minCloudHeight = boundingBox.min.z;
          debug(`Altura mínima de la nube detectada: ${minCloudHeight}`);
        } catch (error) {
          debug(`Error al determinar altura mínima: ${error.message}`);
          // Usar un valor predeterminado si no se puede determinar
          minCloudHeight = 0;
        }

        //-------------------------------------------------------------------------------

        debug("Nube de puntos añadida a la escena");

        // Configuración fija para la visualización de intensidad
        material.activeAttributeName = "intensity";
        material.size = 1;

        // MODIFICACIÓN: Reactivar renderizado adaptativo
        material.pointSizeType = Potree.PointSizeType.ADAPTIVE; // Cambiar de FIXED a ADAPTIVE
        material.shape = Potree.PointShape.SQUARE;

        // Configuración específica para la intensidad
        material.intensityRange = [0, 255];
        material.intensityGamma = 0.43;
        material.intensityBrightness = 0.03;
        material.intensityContrast = -0.06;

        // Ajustes de nivel de detalle (LOD) para optimizar la carga
        pointcloud.minNodeSize = 50; // Reduce de 100 a 50 para mayor detalle a distancia
        pointcloud.maxNodeSize = 300; // Tamaño máximo de nodo a cargar
        pointcloud.progressiveRendering = true; // Activar renderizado progresivo
        viewer.setPointBudget(2_000_000); // Volver a 2M puntos para equilibrar rendimiento

        debug("Configuración de visualización de intensidad aplicada");

        // MODIFICACIÓN: Forzar carga completa de la nube
        pointcloud.showBoundingBox = true; // Mostrar el cuadro delimitador
        pointcloud.generateDEM = false; // Desactivar generación DEM que podría afectar rendimiento

        viewer.fitToScreen();
        debug("Ajustando vista a pantalla completa");

        // Inicializar el administrador de anotaciones
        annotations = viewer.scene.annotations;
        debug("Administrador de anotaciones inicializado");

        // Marcar que la nube está cargada
        cloudLoaded = true;

        // Crear el marcador de referencia
        createReferenceMarker();

        try {
          gpsDB = new GPSDatabase("locations");
          debug("Base de datos AWS inicializada correctamente.");
        } catch (err) {
          console.error("Error al inicializar la base de datos AWS:", err);
          alert("No se pudo conectar con AWS. Verifica la consola.");
        }

        // Comenzar la escucha automática al servidor AWS
        setInterval(() => {
          cargarDesdeAWS();
        }, 10000); // cada 10 segundos

        // Usar la primera coordenada de la matriz como punto inicial
        userLocations.forEach((user) => {
          if (user.lat != null && user.lon != null && user.alt != null) {
            const cloud = convertGPSToCloudCoords(user.lat, user.lon, user.alt);
            if (!cloud) return;
            const marker = createUserMarker(cloud.x, cloud.y, cloud.z, user);
            userMarkers[user.id] = marker;
          }
        });

        // Buscar primer usuario activo para centrar cámara
        let firstAvailable = userLocations.find(
          (user) => user.lat != null && user.lon != null && user.alt != null
        );

        if (firstAvailable) {
          const cloud = convertGPSToCloudCoords(
            firstAvailable.lat,
            firstAvailable.lon,
            firstAvailable.alt
          );
          if (cloud) {
            moveCamera(cloud.x, cloud.y, cloud.z);
            debug(`Cámara centrada sobre usuario activo ${firstAvailable.id}`);
          }
        } else {
          // Si nadie está activo, centrar sobre el punto de origen de la nube
          const origin = referencePoint.cloud;
          if (origin) {
            moveCamera(origin.x, origin.y, origin.z);
            debug("Cámara centrada sobre el punto de origen de la nube");
          }
        }

        // Centrar cámara en el primer usuario
        if (userLocations.length > 0) {
          const first = userLocations[0];
          const cloud = convertGPSToCloudCoords(
            first.lat,
            first.lon,
            first.alt
          );
          if (cloud) moveCamera(cloud.x, cloud.y, cloud.z);
        }

        //

        // Agregar manejadores de eventos para la nube
        pointcloud.addEventListener("visibility_changed", (e) => {
          debug(
            `Visibilidad de la nube cambiada: ${
              e.visible ? "visible" : "invisible"
            }`
          );

          // Si se vuelve invisible durante el renderizado adaptativo
          if (!e.visible && !cameraMoving) {
            setTimeout(() => {
              pointcloud.visible = true;
              debug("Restaurando visibilidad con renderizado adaptativo");

              // Ajustar temporalmente a menos puntos para recuperar visibilidad más rápido
              const currentBudget = viewer.getPointBudget();
              viewer.setPointBudget(Math.min(500000, currentBudget));

              // Restaurar presupuesto original después de recuperar visibilidad
              setTimeout(() => {
                viewer.setPointBudget(currentBudget);
                debug("Restaurando presupuesto de puntos original");
              }, 500);
            }, 100);
          }
        });
        //----------------------------------------------------------------------
      });

      // Variable para almacenar la altura mínima de la nube
      let minCloudHeight = null;

      viewer.addEventListener("update", function () {
        if (!cloudLoaded || !pointcloud) return;

        // Comprobar si la nube está visible
        const isVisible = pointcloud.visible;
        if (!isVisible) {
          debug("ADVERTENCIA: La nube de puntos no es visible actualmente");

          // Reintentar hacer visible la nube
          pointcloud.visible = true;
          viewer.scene.view.setPointCloudsVisible(true);
        }

        // Limitar la altura mínima de la cámara
        if (minCloudHeight !== null) {
          const camera = viewer.scene.getActiveCamera();
          if (camera && camera.position.z < minCloudHeight + 5) {
            debug(`Limitando cámara a altura mínima: ${minCloudHeight + 5}`);
            camera.position.z = minCloudHeight + 5;
            viewer.scene.view.update(
              viewer.scene.getActiveCamera(),
              viewer.scene.pointclouds
            );
          }
        }
      });

      // Funcionalidad adicional para ajustar la vista si hay problemas

      function resetView() {
        if (!cloudLoaded) {
          debug("No se puede reiniciar la vista - la nube no está cargada");
          return;
        }

        debug("Reiniciando vista de la nube...");

        try {
          // Forzar visibilidad
          if (pointcloud) {
            pointcloud.visible = true;
          }

          // Evitar error: primero desactivar cualquier animación pendiente
          if (cameraMoving) {
            cameraMoving = false;
            debug("Cancelando movimiento de cámara previo");
          }

          // Esperar un momento para asegurar que animaciones anteriores hayan terminado
          setTimeout(() => {
            try {
              // MODIFICACIÓN: Usar las coordenadas del marcador GPS si existe
              if (gpsMarker) {
                const pos = gpsMarker.position;
                debug(
                  `Centrando vista en marcador GPS (${pos.x.toFixed(
                    2
                  )}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})`
                );

                // Establecer vista desde una posición elevada mirando al marcador GPS
                const safePosition = [pos.x + 50, pos.y + 50, pos.z + 50];
                const targetPosition = [pos.x, pos.y, pos.z];

                viewer.scene.view.setView(safePosition, targetPosition);
              } else {
                // Si no hay marcador GPS, usar el punto de referencia como respaldo
                debug("No hay marcador GPS, usando punto de referencia");
                const safePosition = [
                  referencePoint.cloud.x + 50,
                  referencePoint.cloud.y + 50,
                  referencePoint.cloud.z + 50,
                ];
                const targetPosition = [
                  referencePoint.cloud.x,
                  referencePoint.cloud.y,
                  referencePoint.cloud.z,
                ];

                viewer.scene.view.setView(safePosition, targetPosition);
              }

              // Asegurar que todas las nubes de puntos estén visibles
              viewer.scene.view.setPointCloudsVisible(true);

              // Forzar una actualización del renderizado
              viewer.scene.dispatchEvent({ type: "update" });

              // Ajustar suavemente la vista después de un breve retraso
              setTimeout(() => {
                try {
                  // Forzar actualización
                  viewer.scene.dispatchEvent({ type: "update" });
                  viewer.scene.dispatchEvent({ type: "pointclouds_loaded" });

                  // Ejecutar la función de estabilización
                  stabilizeView();
                } catch (innerError) {
                  debug(`Error en resetView: ${innerError.message}`);
                }
              }, 500);
            } catch (delayedError) {
              debug(
                `Error durante el reinicio retrasado: ${delayedError.message}`
              );
            }
          }, 100);
        } catch (error) {
          debug(`ERROR al reiniciar vista: ${error.message}`);
          console.error("Error al reiniciar vista:", error);
        }
      }

      //-----------------------------------------------------------------------------

      // Función auxiliar para estabilizar la vista después de fitToScreen
      function stabilizeView() {
        if (!cloudLoaded || !pointcloud) return;

        // Restaurar visibilidad y forzar actualización
        pointcloud.visible = true;
        viewer.scene.view.setPointCloudsVisible(true);

        // Ciclo de actualización progresiva
        const updateSequence = [100, 300, 600];
        updateSequence.forEach((delay) => {
          setTimeout(() => {
            viewer.scene.dispatchEvent({ type: "update" });
            viewer.scene.dispatchEvent({ type: "pointclouds_loaded" });
            debug(`Actualización estabilizadora a ${delay}ms`);
          }, delay);
        });
      }

      // Agregar controlador para teclas de teclado (para debugging)
      document.addEventListener("keydown", function (event) {
        // Tecla 'R' para resetear la vista
        if (event.key === "r" || event.key === "R") {
          resetView();
        }
      });

      //-----------------------------M4------------------------------------

      // Función para verificar y recuperar la visibilidad de la nube
      function checkAndRestoreCloudVisibility() {
        if (!cloudLoaded || !pointcloud) return;

        if (!pointcloud.visible) {
          debug("Detectada pérdida de visibilidad - intentando recuperar");
          pointcloud.visible = true;
          viewer.scene.view.setPointCloudsVisible(true);

          // Forzar actualización de nivel de detalle
          viewer.scene.dispatchEvent({ type: "pointclouds_loaded" });

          // Ajustar la vista cerca del marcador actual si existe
          if (gpsMarker) {
            const pos = gpsMarker.position;
            debug(
              `Reposicionando cerca del marcador (${pos.x.toFixed(
                2
              )}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})`
            );

            // Usar una posición ligeramente diferente para forzar actualización
            viewer.scene.view.setView(
              [pos.x + 10, pos.y + 10, pos.z + 30],
              [pos.x, pos.y, pos.z]
            );
          } else {
            // Si no hay marcador, reset completo
            resetView();
          }
        }
      }

      // Verificar visibilidad cada 3 segundos
      setInterval(checkAndRestoreCloudVisibility, 3000);

      // Función para optimizar la carga inicial
      function optimizeInitialLoading() {
        if (!cloudLoaded || !pointcloud) return;

        debug("Optimizando carga inicial de la nube...");

        // Secuencia de carga progresiva
        const progressiveLoad = (budget, delay) => {
          setTimeout(() => {
            viewer.setPointBudget(budget);
            debug(
              `Incrementando presupuesto de puntos a ${budget.toLocaleString()}`
            );
            viewer.scene.dispatchEvent({ type: "update" });
          }, delay);
        };

        // Comenzar con pocos puntos y aumentar progresivamente
        viewer.setPointBudget(500000); // Inicio con pocos puntos
        progressiveLoad(1000000, 1000); // 1M después de 1 segundo
        progressiveLoad(1500000, 2000); // 1.5M después de 2 segundos
        progressiveLoad(2000000, 3000); // 2M después de 3 segundos
        progressiveLoad(2500000, 4000); // 2.5M después de 4 segundos
      }

      // Inicializar el panel desplegable
      document.addEventListener("DOMContentLoaded", function () {
        // Configurar el toggle del panel desplegable
        const toggleBtn = document.getElementById("toggle-panel");
        const pointsPanel = document.getElementById("points-panel");

        // Estado inicial: expandido
        let isPanelCollapsed = false;

        toggleBtn.addEventListener("click", function () {
          isPanelCollapsed = !isPanelCollapsed;

          if (isPanelCollapsed) {
            pointsPanel.classList.add("panel-collapsed");
            toggleBtn.textContent = "≫";
          } else {
            pointsPanel.classList.remove("panel-collapsed");
            toggleBtn.textContent = "≪";
          }

          debug(
            `Panel de puntos ${isPanelCollapsed ? "contraído" : "expandido"}`
          );
        });

        debug("Panel desplegable de puntos GPS inicializado");
      });

      // Llamar a la función de optimización después de cargar la nube
      // Añade esta línea al final del bloque donde se carga la nube de puntos (línea ~465)
      setTimeout(optimizeInitialLoading, 1000);

      //----------------------------

      // Configurar los botones del panel de control lateral
      document.addEventListener("DOMContentLoaded", function () {
        setTimeout(() => {
          try {
            // Configurar botón Full Extent
            document
              .getElementById("btn-full-extent")
              .addEventListener("click", function () {
                try {
                  debug("Iniciando ajuste a pantalla completa");

                  // Detener cualquier movimiento de cámara en progreso
                  if (cameraMoving) {
                    cameraMoving = false;
                    debug("Deteniendo movimiento de cámara previo");
                  }

                  // Asegurar que la nube es visible
                  if (pointcloud) {
                    pointcloud.visible = true;
                  }

                  // Crear una secuencia controlada de actualización
                  setTimeout(() => {
                    try {
                      // Método 1: Usar fitToScreen directamente
                      viewer.fitToScreen();
                      debug("Vista ajustada con fitToScreen");

                      // Forzar actualización de la escena después del ajuste
                      setTimeout(() => {
                        viewer.scene.dispatchEvent({ type: "update" });
                        viewer.scene.dispatchEvent({
                          type: "pointclouds_loaded",
                        });
                        debug("Forzando actualización posterior al ajuste");
                      }, 100);
                    } catch (fitError) {
                      debug(`Error en fitToScreen: ${fitError.message}`);

                      // Método 2 (alternativo): Ajuste manual usando las dimensiones de la nube
                      try {
                        if (pointcloud && pointcloud.boundingBox) {
                          const bbox = pointcloud.boundingBox;
                          const center = bbox.getCenter();
                          const size = bbox.getSize();
                          const maxDim = Math.max(size.x, size.y, size.z);

                          // Calcular una posición elevada mirando al centro
                          const cameraPos = [
                            center.x,
                            center.y - maxDim,
                            center.z + maxDim / 2,
                          ];

                          // Aplicar vista manualmente
                          viewer.scene.view.setView(cameraPos, [
                            center.x,
                            center.y,
                            center.z,
                          ]);
                          debug(
                            "Vista ajustada manualmente usando boundingBox"
                          );
                        } else {
                          // Método 3: Usar la función de resetView como último recurso
                          resetView();
                        }
                      } catch (manualError) {
                        debug(`Error en ajuste manual: ${manualError.message}`);
                        resetView();
                      }
                    }
                  }, 50);
                } catch (error) {
                  debug(`ERROR en Full Extent: ${error.message}`);
                  console.error("Error en Full Extent:", error);

                  // Último recurso
                  alert(
                    "Error al ajustar la vista. Intente de nuevo en unos segundos."
                  );
                }
              });

            ///

            // Añadir después de la configuración del botón Full Extent (línea ~738)
            // Función mejorada para el botón Full Extent
            document
              .getElementById("btn-full-extent")
              .addEventListener("click", function () {
                try {
                  debug("Intentando ajustar a pantalla completa");

                  // Primero aseguramos que la nube es visible
                  if (pointcloud) {
                    pointcloud.visible = true;
                  }

                  // Pequeña pausa para asegurar que todo está listo
                  setTimeout(() => {
                    try {
                      viewer.fitToScreen();
                      debug("Vista ajustada a pantalla completa exitosamente");

                      // Forzar actualización adicional después de fitToScreen
                      setTimeout(() => {
                        viewer.scene.dispatchEvent({ type: "update" });
                      }, 200);
                    } catch (e) {
                      debug(`Error en fitToScreen: ${e.message}`);

                      // Plan B: usar resetView como alternativa
                      resetView();
                    }
                  }, 50);
                } catch (error) {
                  debug(
                    `ERROR al ajustar a pantalla completa: ${error.message}`
                  );
                }
              });

            //

            document
              .getElementById("btn-move-5m")
              .addEventListener("click", function () {
                if (!cloudLoaded) {
                  debug(
                    "Nube no cargada, no se puede mover a la siguiente coordenada"
                  );
                  return;
                }

                // Avanzar al siguiente punto
                gpsIndex = (gpsIndex + 1) % gpsCoordinateList.length;
                const newCoords = gpsCoordinateList[gpsIndex];
                debug(
                  `Moviendo a siguiente coordenada [${gpsIndex}]:`,
                  newCoords
                );

                const cloudCoords = convertGPSToCloudCoords(
                  newCoords.lat,
                  newCoords.lon,
                  newCoords.alt
                );
                updateMarker(
                  cloudCoords.x,
                  cloudCoords.y,
                  cloudCoords.z,
                  newCoords.lat,
                  newCoords.lon,
                  newCoords.alt
                );
              });

            //
            // Asegúrate de que los iconos estén visibles y sean clicables
            const buttons = document.querySelectorAll("#left-toolbar button");
            buttons.forEach((button) => {
              // Forzar visibilidad y estilos correctos
              const icon = button.querySelector("i");
              if (icon) {
                icon.style.display = "block";
                icon.style.visibility = "visible";
                icon.style.opacity = "1";
              }

              // Añadir clases adicionales para asegurar funcionamiento
              button.style.cursor = "pointer";
              button.style.display = "flex";
              button.style.justifyContent = "center";
              button.style.alignItems = "center";

              debug(`Botón configurado: ${button.id}`);
            });

            debug("Panel de control lateral configurado correctamente");
          } catch (e) {
            debug(`Error al configurar panel de control lateral: ${e.message}`);
          }
        }, 3000); // Aumentar a 3 segundos para asegurar que todo esté cargado
      });

      // Añadir al final de la configuración de los botones del panel de control lateral (línea ~755)
      // Forzar carga específica del icono Full Extent
      const fullExtentIcon = document.querySelector(".potree_full_extent_icon");
      if (fullExtentIcon) {
        fullExtentIcon.style.backgroundImage =
          "url('./libs/potree/resources/icons/fit.svg')";
        debug("Icono Full Extent forzado");
      }

      //-------------------------------------
      // Función para asegurar que los iconos se cargan correctamente
      function ensureIconsLoaded() {
        const toolbarButtons = document.querySelectorAll(
          "#left-toolbar button i"
        );
        toolbarButtons.forEach((icon) => {
          // Forzar recarga del estilo del icono
          const computedStyle = window.getComputedStyle(icon);
          if (
            computedStyle.backgroundImage === "none" ||
            computedStyle.width === "0px"
          ) {
            // Recargar el icono aplicando nuevamente la clase
            const className = Array.from(icon.classList).find((cls) =>
              cls.includes("potree_")
            );
            if (className) {
              icon.classList.remove(className);
              setTimeout(() => icon.classList.add(className), 10);
            }
          }
        });
      }

      // Llamar a la función después de cargar la página y nuevamente después de un segundo
      document.addEventListener("DOMContentLoaded", function () {
        setTimeout(ensureIconsLoaded, 500);
        setTimeout(ensureIconsLoaded, 1500);
      });
    </script>
  </body>
</html>
