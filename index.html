<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="description" content="Sistema GPS con Nube de Puntos Potree" />
    <meta name="author" content="" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>Sistema GPS Potree</title>

    <link rel="stylesheet" type="text/css" href="./libs/potree/potree.css" />
    <link
      rel="stylesheet"
      type="text/css"
      href="./libs/jquery-ui/jquery-ui.min.css"
    />
    <link rel="stylesheet" type="text/css" href="./libs/openlayers3/ol.css" />
    <link rel="stylesheet" type="text/" href="./libs/spectrum/spectrum.css" />
    <link
      rel="stylesheet"
      type="text/css"
      href="./libs/jstree/themes/mixed/style.css"
    />

    <script src="https://sdk.amazonaws.com/js/aws-sdk-2.1480.0.min.js"></script>

    <style>
      .coordinate-display {
        margin-top: 10px;
        padding: 5px;
        background: rgba(0, 0, 0, 0.1);
        border-radius: 3px;
      }

      .point-item.selected {
        background-color: rgba(
          255,
          255,
          0,
          0.2
        ); /* Amarillo claro transl√∫cido */
        border-left: 4px solid gold;
        border-radius: 6px;
      }
      #debug-panel {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        padding: 10px;
        border-radius: 5px;
        z-index: 1000;
        width: 400px;
        max-height: 200px;
        overflow-y: auto;
        font-family: monospace;
        font-size: 12px;
      }

      .marker-label {
        color: white;
        background-color: rgba(0, 0, 0, 0.6);
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 12px;
        font-weight: bold;
        white-space: nowrap;
        pointer-events: none;
      }

      #simple-controls {
        position: absolute;
        bottom: 30px;
        right: 10px;
        background: rgba(255, 255, 255, 0.8);
        padding: 10px;
        border-radius: 5px;
        z-index: 1000;
        display: flex;
        flex-direction: column;
      }

      #simple-controls button {
        margin: 5px;
        padding: 8px;
        background-color: #4caf50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        width: 180px;
      }

      #simple-controls button:hover {
        background-color: #45a049;
      }

      #left-toolbar {
        position: absolute;
        right: 10px;
        left: auto;
        top: 50%;
        transform: translateY(-50%);
        background: rgba(255, 255, 255, 0.8);
        padding: 10px;
        border-radius: 5px;
        z-index: 1000;
        display: flex;
        flex-direction: column;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      }

      #left-toolbar button {
        margin: 5px 0;
        padding: 8px;
        background-color: #4caf50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        width: 40px;
        height: 40px;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      #left-toolbar button:hover {
        background-color: #45a049;
      }

      #left-toolbar button i {
        font-size: 20px;
      }

      /*********************************************** Iconos de Potree */
      /* Mejorar la carga de iconos con rutas absolutas */
      .potree_full_extent_icon::before {
        content: "";
        display: inline-block;
        width: 24px;
        height: 24px;
        background-image: url("./libs/potree/resources/icons/helicopter_controls.svg");
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
      }

      .potree_move_icon::before {
        content: "";
        display: inline-block;
        width: 24px;
        height: 24px;
        background-image: url("./libs/potree/resources/icons/arrow_right.svg");
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
      }

      .potree_home_icon::before {
        content: "";
        display: inline-block;
        width: 24px;
        height: 24px;
        background-image: url("./libs/potree/resources/icons/earth_controls_1.png");
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
      }

      /*********************************************** Iconos de Potree */

      /* Paso 5: A√±ade estilos para mejorar la visualizaci√≥n de los botones */
      #left-toolbar button {
        position: relative;
        overflow: visible;
      }

      #left-toolbar button i {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 24px;
        height: 24px;
      }

      /* Eliminar completamente el panel de Potree */
      #potree_sidebar_container,
      .potree_container .sidebar,
      .potree_menu_toggle,
      .potree_logo,
      .potree_menu_buttons,
      .potree_tool_icon,
      #potree_sidebar_container * {
        display: none !important;
        width: 0 !important;
        height: 0 !important;
        visibility: hidden !important;
        opacity: 0 !important;
        pointer-events: none !important;
        overflow: hidden !important;
        position: absolute !important;
        left: -9999px !important;
      }

      /* Asegurarse que no queden rastros del panel */
      .potree_container {
        position: absolute;
        width: 100%;
        height: 100%;
        left: 0px !important;
        right: 0px !important;
        pointer-events: auto;
      }

      #potree_render_area {
        left: 0px !important;
        right: 0px !important;
        width: 100% !important;
        position: absolute;
      }

      #points-panel {
        position: absolute;
        top: 10px;
        left: 10px;
        width: 320px;
        height: 500px; /* Alto fijo: aproximadamente 3 cajas de usuario */
        background-color: rgba(255, 255, 255, 0.85);
        border-radius: 12px;
        border: 1px solid #ccc;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        overflow: hidden;
        display: flex;
        flex-direction: column;
        transition: transform 0.3s ease;
        z-index: 10;
      }

      #points-panel-header {
        padding: 10px;
        background: #4caf50;
        color: white;
        border-radius: 5px 5px 0 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
      }

      #points-panel-content {
        padding: 0;
        overflow-y: auto;
        max-height: calc(80vh - 40px);
      }

      .point-item {
        padding: 10px 12px;
        margin-bottom: 8px;
        background-color: rgba(255, 255, 255, 0.95);
        border: 1px solid rgba(0, 0, 0, 0.25); /* Borde gris oscuro */
        border-radius: 8px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15);
        display: flex;
        align-items: center;
        cursor: pointer;
        transition: background-color 0.3s, box-shadow 0.3s;
      }

      .point-item:last-child {
        border-bottom: none;
      }

      .point-icon {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background-color: #ff0000;
        margin-right: 10px;
        flex-shrink: 0;
      }

      .point-details {
        flex-grow: 1;
      }

      .point-title {
        font-weight: bold;
        margin-bottom: 5px;
      }

      .point-coords {
        font-size: 12px;
        color: #666;
        font-family: monospace;
      }

      .panel-collapsed {
        transform: translateX(-290px);
      }

      .toggle-btn {
        background: none;
        border: none;
        cursor: pointer;
        font-size: 18px;
        color: white;
        padding: 0;
      }

      .point-item:hover {
        background-color: rgba(76, 175, 80, 0.1); /* Verde claro transl√∫cido */
        box-shadow: 0 0 8px rgba(76, 175, 80, 0.3); /* Sombra verde tenue */
        border-radius: 5px;
      }

      #loading-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #111;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 9999;
        transition: opacity 0.5s ease;
      }

      .loading-box {
        text-align: center;
      }

      .spinner {
        border: 6px solid #444;
        border-top: 6px solid #00ff99;
        border-radius: 50%;
        width: 60px;
        height: 60px;
        animation: spin 1s linear infinite;
        margin: 0 auto 15px auto;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .logo-title {
        font-family: "Segoe UI", sans-serif;
        font-size: 36px;
        font-weight: bold;
        color: #00ff99;
        margin-bottom: 20px;
        letter-spacing: 2px;
        text-shadow: 0 0 10px #00ff99;
      }

      #north-compass {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 60px;
        height: 75px; /* aumentamos altura para dar espacio a la N */
        z-index: 1001;
        background-color: rgba(255, 255, 255, 0.85);
        border-radius: 12px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        padding: 4px;
        display: flex;
        align-items: center;
        justify-content: flex-start;
        border: 1px solid #ccc;
        flex-direction: column;
        gap: 0;
      }

      #north-label {
        color: red;
        font-weight: 900; /* m√°s gruesa */
        font-size: 16px;
        line-height: 16px;
        margin-bottom: -4px;
        user-select: none;
        pointer-events: none;
        font-family: sans-serif;
      }

      #north-arrow {
        transition: transform 0.3s ease;
      }
    </style>
  </head>

  <body>
    <script src="./libs/jquery/jquery-3.1.1.min.js"></script>
    <script src="./libs/spectrum/spectrum.js"></script>
    <script src="./libs/jquery-ui/jquery-ui.min.js"></script>
    <script src="./libs/three.js/build/three.min.js"></script>
    <script src="./libs/three.js/extra/lines.js"></script>
    <script src="./libs/other/BinaryHeap.js"></script>
    <script src="./libs/tween/tween.min.js"></script>
    <script src="./libs/d3/d3.js"></script>
    <script src="./libs/proj4/proj4.js"></script>
    <script src="./libs/openlayers3/ol.js"></script>
    <script src="./libs/i18next/i18next.js"></script>
    <script src="./libs/jstree/jstree.js"></script>
    <script src="./libs/potree/potree.js"></script>
    <script src="./libs/plasio/js/laslaz.js"></script>

    <div
      class="potree_container"
      style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px"
    >
      <div
        id="potree_render_area"
        style="
          background-image: url('./libs/potree/resources/images/background.jpg');
        "
      ></div>
      <div
        id="potree_sidebar_container"
        style="
          display: none !important;
          width: 0;
          height: 0;
          overflow: hidden;
          position: absolute;
        "
      ></div>

      <div id="left-toolbar">
        <button id="btn-full-extent" title="Pantalla Completa">
          <i class="potree_full_extent_icon"></i>
        </button>
        <button id="btn-move-5m" title="Trayectorias">
          <i class="potree_move_icon"></i>
        </button>
        <button id="btn-home" title="Ir al Origen">
          <i class="potree_home_icon"></i>
        </button>
      </div>
    </div>

    <div id="north-compass">
      <div id="north-label">N</div>
      <svg id="north-arrow" viewBox="0 0 100 100" width="100%" height="100%">
        <!-- C√≠rculo de fondo verde -->
        <circle
          cx="50"
          cy="50"
          r="45"
          stroke="#bbb"
          stroke-width="3"
          fill="#4CAF50"
        />

        <!-- Aguja norte (roja) -->
        <polygon points="50,20 60,50 40,50" fill="red" />

        <!-- Aguja sur (blanca) -->
        <polygon points="40,50 60,50 50,80" fill="white" />
      </svg>
    </div>

    <!-- Eliminar completamente el panel de depuraci√≥n en lugar de ocultarlo -->
    <div
      id="debug-panel"
      style="
        display: none !important;
        width: 0;
        height: 0;
        overflow: hidden;
        position: absolute;
        visibility: hidden;
        opacity: 0;
      "
    >
      <!-- El contenido se mantendr√° invisible y completamente eliminado del flujo del documento -->
    </div>

    <!-- Nuevo panel desplegable para puntos -->
    <div id="points-panel" class="panel-collapsed">
      <div id="points-panel-header">
        <span>Puntos GPS</span>
        <button class="toggle-btn" id="toggle-panel">‚â™</button>
      </div>
      <div id="points-panel-content">
        <!-- Los puntos se agregar√°n din√°micamente aqu√≠ -->
      </div>
    </div>

    <script>
      // Funci√≥n para mostrar mensajes de depuraci√≥n
      function debug(message) {
        // Solo env√≠a a la consola, no al panel visual
        console.log(`[DEBUG] ${message}`);
      }

      debug("Iniciando aplicaci√≥n...");

      // Inicializar el visor Potree
      window.viewer = new Potree.Viewer(
        document.getElementById("potree_render_area")
      );
      const MAX_PUNTOS_CARGA = 2_500_000; // Puedes ajustar f√°cilmente esta constante global

      // Configuraci√≥n del visor
      viewer.setEDLEnabled(true);
      viewer.setFOV(60);
      viewer.setPointBudget(MAX_PUNTOS_CARGA);
      viewer.setBackground("gradient");
      viewer.loadSettingsFromURL();

      debug(
        "Visor Potree inicializado correctamente con densidad m√°xima fija de 2,500,000 puntos"
      );

      // Variables globales
      let gpsMarker = null;
      let camaraEnganchadaA = null; // ID del usuario actualmente enganchado

      const userLocations = new Map(); // key: id, value: { lat, lon, alt, color }

      // Mapa de ID a marcador (para actualizaci√≥n futura)
      const userMarkers = {};
      const flechasHeading = {}; // id ‚Üí Mesh de flecha
      const estadoUsuarios = new Map(); // id ‚Üí { ultimoTimestamp, ciclosSinCambio }
      const MAX_CICLOS_SIN_CAMBIO = 3; // puedes ajustar este valor
      const DIRECCION_INICIAL = new THREE.Vector3(
        524823.59,
        1215810.79,
        31.979999999999983
      ); // vector de enfoque

      let annotations = null;
      let pointcloud = null;
      let labelDiv = null;
      let cloudLoaded = false;
      let referenceMarker = null;
      let cameraMoving = false;
      let gpsBlinkInterval = null;
      let gpsDB = null;
      let planoBoundingBox = null;
      let limitesCuboDinamico = null;
      const ROTACION_Z_GRADOS = 45;
      let ultimaPosicionCamara = new Map(); // id ‚Üí { x, y, z }
      window.trayectoriasPorUsuario = new Map(); // id ‚Üí lista de posiciones por usuario
      window.trayectoriasLineas = new Map(); // id ‚Üí objeto THREE.Line por usuario

      //-------------------------------------------------------------

      function crearPlanoBoundingBox() {
        if (!referencePoint || !referencePoint.cloud) {
          console.warn("‚ùó El punto de referencia no est√° listo.");
          return;
        }

        // üîß Ajusta estas dimensiones manualmente
        const DIM_X = 1000;
        const DIM_Y = 5800;
        const DIM_Z = 60;

        const geometry = new THREE.BoxGeometry(DIM_X, DIM_Y, DIM_Z);
        const material = new THREE.MeshBasicMaterial({
          color: 0xff4444,
          transparent: true,
          opacity: 0.2,
        });

        planoBoundingBox = new THREE.Mesh(geometry, material);
        planoBoundingBox.position.set(523478.49, 1216781.51, 35.09);

        const rotZ = (ROTACION_Z_GRADOS * Math.PI) / 180;
        planoBoundingBox.rotation.set(0, 0, rotZ); // üëâ Esto fuerza que est√© perfectamente alineado

        viewer.scene.scene.add(planoBoundingBox);

        // üî≤ Contorno blanco (wireframe)
        const wireframe = new THREE.EdgesGeometry(geometry);
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
        const lines = new THREE.LineSegments(wireframe, lineMaterial);
        lines.position.copy(planoBoundingBox.position);
        lines.rotation.set(0, 0, rotZ); // üëâ Asegura misma orientaci√≥n que el cubo
        viewer.scene.scene.add(lines);

        debug("üü• Cubo de bounding box creado correctamente.");
        actualizarLimitesDesdeCubo();
      }

      function actualizarLimitesDesdeCubo() {
        if (!planoBoundingBox) return;

        const center = planoBoundingBox.position;
        const size = planoBoundingBox.geometry.parameters;
        const rotZ = planoBoundingBox.rotation.z;

        limitesCuboDinamico = {
          center: { x: center.x, y: center.y, z: center.z },
          size: { x: size.width, y: size.height, z: size.depth },
          rotZ,
        };
      }

      function moverCuboEnDireccion(distancia, anguloGrados) {
        if (!planoBoundingBox) return;

        const rad = (anguloGrados * Math.PI) / 180;
        const dx = Math.cos(rad) * distancia;
        const dy = Math.sin(rad) * distancia;

        planoBoundingBox.position.x += dx;
        planoBoundingBox.position.y += dy;

        // Mover tambi√©n el contorno
        viewer.scene.scene.children.forEach((obj) => {
          if (
            obj.type === "LineSegments" &&
            obj.geometry instanceof THREE.EdgesGeometry
          ) {
            obj.position.x += dx;
            obj.position.y += dy;
          }
        });
        actualizarLimitesDesdeCubo();
        debug(
          `üì¶ Cubo movido: Œîx=${dx.toFixed(2)}, Œîy=${dy.toFixed(
            2
          )} (√°ngulo ${anguloGrados}¬∞)`
        );
      }

      function mostrarDimensionesYCentroDelCubo() {
        if (!planoBoundingBox) return;

        const { x, y, z } = planoBoundingBox.position;
        const {
          width: dx,
          height: dy,
          depth: dz,
        } = planoBoundingBox.geometry.parameters;

        debug(
          `üìè Centro del cubo: x=${x.toFixed(2)}, y=${y.toFixed(
            2
          )}, z=${z.toFixed(2)}`
        );
        debug(`üì¶ Dimensiones: ancho=${dx}, largo=${dy}, alto=${dz}`);
      }

      function togglePlanoBoundingBox() {
        if (!planoBoundingBox) {
          crearPlanoBoundingBox();
        } else {
          const visible = !planoBoundingBox.visible;
          planoBoundingBox.visible = visible;
          viewer.scene.scene.children.forEach((obj) => {
            if (
              obj.type === "LineSegments" &&
              obj.geometry instanceof THREE.EdgesGeometry
            ) {
              obj.visible = visible;
            }
          });
          debug(`üü• Cubo de bounding box ${visible ? "visible" : "oculto"}`);
        }
      }

      // Funci√≥n para convertir coordenadas en formato DMS (grados, minutos, segundos) a decimal
      function dmsToDecimal(degrees, minutes, seconds, direction) {
        let decimal = degrees + minutes / 60 + seconds / 3600;
        // Si la direcci√≥n es Sur (S) o Oeste (W/O), el valor debe ser negativo
        if (direction === "S" || direction === "W" || direction === "O") {
          decimal = -decimal;
        }
        return decimal;
      }

      //--------------------------------------------------------------

      function headingToCompass(deg) {
        if (deg === undefined || deg === null || deg < 0) return "‚Äî";
        const sectores = [
          "Norte",
          "Noreste",
          "Este",
          "Sureste",
          "Sur",
          "Suroeste",
          "Oeste",
          "Noroeste",
        ];
        const idx = Math.floor(((deg + 22.5) % 360) / 45);
        return sectores[idx];
      }

      // Funci√≥n para convertir coordenadas decimales a formato DMS (grados, minutos, segundos)
      function decimalToDMS(decimal, isLatitude) {
        // Asegurar que el valor es positivo para el c√°lculo
        const absDecimal = Math.abs(decimal);

        // Calcular grados (parte entera)
        const degrees = Math.floor(absDecimal);

        // Calcular minutos (parte decimal * 60, y luego tomar la parte entera)
        const minutesDecimal = (absDecimal - degrees) * 60;
        const minutes = Math.floor(minutesDecimal);

        // Calcular segundos (parte decimal de los minutos * 60)
        const seconds = ((minutesDecimal - minutes) * 60).toFixed(2);

        // Determinar la direcci√≥n (N/S para latitud, E/O para longitud)
        let direction;
        if (isLatitude) {
          direction = decimal >= 0 ? "N" : "S";
        } else {
          direction = decimal >= 0 ? "E" : "O";
        }

        // Formatear el resultado
        return `${degrees}¬∞ ${minutes}' ${seconds}" ${direction}`;
      }

      window.awsConfig = {
        region: "us-east-1",
        accessKeyId: "AKIAZCRUSKBBWDBPX4PN",
        secretAccessKey: "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",
      };

      // Punto de referencia conocido para la conversi√≥n (aleta de tibur√≥n)
      const referencePoint = {
        // Coordenadas GPS en formato crudo
        gpsRaw: {
          lat: { degrees: 10, minutes: 59, seconds: 54.22, direction: "N" },
          lon: { degrees: 74, minutes: 46, seconds: 21.87, direction: "O" },
          alt: 3, // 3 metros
        },
        // Coordenadas GPS (latitud, longitud, altitud) en decimal
        gps: {
          lat: null, // Se calcular√° a continuaci√≥n
          lon: null, // Se calcular√° a continuaci√≥n
          alt: 3, // 3 metros
        },
        // Coordenadas en la nube Potree
        cloud: {
          x: 524823.59,
          y: 1215810.79,
          z: 31.98,
        },
      };

      // Convertir coordenadas crudas a decimal
      referencePoint.gps.lat = dmsToDecimal(
        referencePoint.gpsRaw.lat.degrees,
        referencePoint.gpsRaw.lat.minutes,
        referencePoint.gpsRaw.lat.seconds,
        referencePoint.gpsRaw.lat.direction
      );

      referencePoint.gps.lon = dmsToDecimal(
        referencePoint.gpsRaw.lon.degrees,
        referencePoint.gpsRaw.lon.minutes,
        referencePoint.gpsRaw.lon.seconds,
        referencePoint.gpsRaw.lon.direction
      );

      // Agregar mensaje de depuraci√≥n para confirmar la conversi√≥n
      debug(`Punto de referencia (convertido): 
            GPS: (${referencePoint.gps.lat}, ${referencePoint.gps.lon}, ${referencePoint.gps.alt})
            Nube: (${referencePoint.cloud.x}, ${referencePoint.cloud.y}, ${referencePoint.cloud.z})`);

      //----------------------------------------------------------------------

      debug(`Punto de referencia configurado: 
            GPS: (${referencePoint.gps.lat}, ${referencePoint.gps.lon}, ${referencePoint.gps.alt})
            Nube: (${referencePoint.cloud.x}, ${referencePoint.cloud.y}, ${referencePoint.cloud.z})`);

      //----------------------------------------------------------------------------

      // Funci√≥n para convertir coordenadas GPS a coordenadas de la nube
      function convertGPSToCloudCoords(lat, lon, alt) {
        debug(
          `Convirtiendo coordenadas GPS (${lat}, ${lon}, ${alt}) a coordenadas de nube...`
        );

        try {
          // Calculamos la diferencia en grados
          const dLat = lat - referencePoint.gps.lat;
          const dLon = lon - referencePoint.gps.lon;
          const dAlt = alt - referencePoint.gps.alt;

          // Conversi√≥n aproximada: 1 grado de latitud ‚âà 111.32 km = 111320 metros
          // En el Ecuador, 1 grado de longitud ‚âà 111.32 km, pero var√≠a con la latitud
          // Factor de correcci√≥n para longitud: cos(latitud en radianes)
          const lonCorrectionFactor = Math.cos(
            (referencePoint.gps.lat * Math.PI) / 180
          );

          // Convertimos diferencias en grados a metros (aproximado)
          const dY = dLat * 111320; // Norte-Sur
          const dX = dLon * 111320 * lonCorrectionFactor; // Este-Oeste

          // Aplicamos la diferencia a las coordenadas de la nube
          const cloudX = referencePoint.cloud.x + dX;
          const cloudY = referencePoint.cloud.y + dY;
          const cloudZ = referencePoint.cloud.z + dAlt;

          debug(
            `Coordenadas convertidas: (${cloudX.toFixed(2)}, ${cloudY.toFixed(
              2
            )}, ${cloudZ.toFixed(2)})`
          );

          return {
            x: cloudX,
            y: cloudY,
            z: cloudZ,
          };
        } catch (error) {
          debug(`ERROR en la conversi√≥n de coordenadas: ${error.message}`);
          console.error("Error en la conversi√≥n de coordenadas:", error);
          return null;
        }
      }

      //-------------------------------------------------------------------------------

      // Funci√≥n para crear/actualizar el marcador en la nube
      function updateMarker(x, y, z, lat = null, lon = null, alt = null) {
        debug(
          `Intentando crear marcador en (${x.toFixed(2)}, ${y.toFixed(
            2
          )}, ${z.toFixed(2)})...`
        );

        // Si no se proporcionan coordenadas GPS, intentar calcularlas inversamente (aproximaci√≥n)
        if (lat === null || lon === null || alt === null) {
          // Este es un c√°lculo inverso aproximado
          const dX = x - referencePoint.cloud.x;
          const dY = y - referencePoint.cloud.y;
          const dZ = z - referencePoint.cloud.z;

          // Factor de correcci√≥n para longitud: cos(latitud en radianes)
          const lonCorrectionFactor = Math.cos(
            (referencePoint.gps.lat * Math.PI) / 180
          );

          // Convertir diferencias en metros a grados (aproximado)
          const dLat = dY / 111320;
          const dLon = dX / (111320 * lonCorrectionFactor);

          lat = referencePoint.gps.lat + dLat;
          lon = referencePoint.gps.lon + dLon;
          alt = referencePoint.gps.alt + dZ;
        }

        // Resto del c√≥digo de la funci√≥n updateMarker...

        try {
          // Eliminar marcador anterior si existe
          if (gpsMarker) {
            viewer.scene.scene.remove(gpsMarker);
            debug("Marcador anterior eliminado");
          }

          // Iniciar efecto de parpadeo
          if (gpsBlinkInterval) {
            clearInterval(gpsBlinkInterval);
          }

          let visible = true;
          gpsBlinkInterval = setInterval(() => {
            if (gpsMarker && gpsMarker.material) {
              gpsMarker.material.opacity = visible ? 0.0 : 0.8;
              gpsMarker.material.needsUpdate = true;
              visible = !visible;
            }
          }, 500); // 500ms = 0.5 segundos

          // Eliminar etiqueta anterior si existe
          if (labelDiv) {
            const container = document.getElementById("potree_render_area");
            container.removeChild(labelDiv);
            labelDiv = null;
            debug("Etiqueta anterior eliminada");
          }

          // Crear nuevo marcador (esfera roja)
          const sphereGeometry = new THREE.SphereGeometry(2, 32, 32);
          const sphereMaterial = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            opacity: 0.8,
            transparent: true,
          });
          gpsMarker = new THREE.Mesh(sphereGeometry, sphereMaterial);
          gpsMarker.position.set(x, y, z);
          viewer.scene.scene.add(gpsMarker);
          debug("Marcador (esfera) creado y a√±adido a la escena");

          // Crear etiqueta
          labelDiv = document.createElement("div");
          labelDiv.className = "marker-label";
          labelDiv.style.position = "absolute";
          labelDiv.style.padding = "10px";
          labelDiv.style.background = "rgba(0, 0, 0, 0.7)";
          labelDiv.style.color = "white";
          labelDiv.style.borderRadius = "5px";
          labelDiv.style.pointerEvents = "none";
          labelDiv.style.zIndex = "1000";
          labelDiv.innerHTML = `
                    <span style="font-weight: bold;">Posici√≥n GPS</span><br>
                    X: ${x.toFixed(2)}, Y: ${y.toFixed(2)}, Z: ${z.toFixed(2)}
                `;

          // A√±adir etiqueta al contenedor
          const container = document.getElementById("potree_render_area");
          container.appendChild(labelDiv);

          // Actualizar posici√≥n de la etiqueta en cada frame
          function updateLabelPosition() {
            if (!gpsMarker) return;

            // Verificar si la c√°mara y el marcador existen
            const camera = viewer.scene.getActiveCamera();
            if (!camera) return;

            const screenPos = gpsMarker.position.clone().project(camera);

            // Verificar si el punto est√° delante de la c√°mara (z < 1)
            if (screenPos.z < 1) {
              // Convertir a coordenadas de pantalla
              const x = ((screenPos.x + 1) * container.clientWidth) / 2;
              const y = ((-screenPos.y + 1) * container.clientHeight) / 2;

              // Actualizar posici√≥n de la etiqueta
              labelDiv.style.left = `${x}px`;
              labelDiv.style.top = `${y - 50}px`; // Desplazar un poco arriba
              labelDiv.style.display = "block";
            } else {
              // Ocultar la etiqueta si est√° detr√°s de la c√°mara
              labelDiv.style.display = "none";
            }

            requestAnimationFrame(updateLabelPosition);
          }

          // Iniciar la actualizaci√≥n
          updateLabelPosition();

          // Mostrar las coordenadas convertidas en la interfaz
          document.getElementById("cloud-coords").textContent = `X: ${x.toFixed(
            2
          )}, Y: ${y.toFixed(2)}, Z: ${z.toFixed(2)}`;

          // Mover la c√°mara de forma suave
          moveCamera(x, y, z);

          debug("Coordenadas convertidas mostradas en la interfaz");
        } catch (error) {
          debug(`ERROR al crear marcador: ${error.message}`);
          console.error("Error al crear marcador:", error);
        }

        // Actualizar el panel desplegable con las coordenadas del marcador
        updatePointPanel(x, y, z, lat, lon, alt);
      }

      //--------------------------------------------------------------------------------

      function createUserMarker(x, y, z, user, cloud) {
        const geometry = new THREE.SphereGeometry(1.0, 16, 16); // Tama√±o corregido
        const material = new THREE.MeshBasicMaterial({ color: user.color });
        const marker = new THREE.Mesh(geometry, material);

        // üí° Efecto de parpadeo
        marker.onBeforeRender = function (
          renderer,
          scene,
          camera,
          geometry,
          material,
          group
        ) {
          const t = performance.now() * 0.0035; // sincronizado con flecha
          const scale = 1 + 0.25 * Math.sin(t);
          marker.scale.set(scale, scale, scale);
        };

        marker.position.set(x, y, z);
        viewer.scene.scene.add(marker);

        const div = document.createElement("div");
        div.className = "point-item";
        div.id = `user-panel-${user.id}`;
        //-----------------------------------------
        const velocidadTexto =
          typeof user.speed === "number" && !isNaN(user.speed)
            ? `Velocidad: ${user.speed.toFixed(3)} m/s<br>`
            : "";

        const rumboTexto =
          typeof user.heading === "number" && !isNaN(user.heading)
            ? `Rumbo: ${headingToCompass(user.heading)}<br>`
            : "";

        div.innerHTML = `
                <div class="point-icon" style="background-color: ${
                  user.color
                };"></div>
                <div class="point-details">
                    <div class="point-title">Usuario ${user.id}</div>
                    <div class="point-coords">
                        Lat: ${decimalToDMS(user.lat, true)}<br>
                        Lon: ${decimalToDMS(user.lon, false)}<br>
                        Alt: ${user.alt.toFixed(2)} m<br>
                        ${velocidadTexto}
                        ${rumboTexto}
                        <small>Nube: X=${cloud.x.toFixed(
                          2
                        )}, Y=${cloud.y.toFixed(2)}, Z=${cloud.z.toFixed(
          2
        )}</small>
                    </div>
                    <div class="follow-status" style="font-size: 12px; color: green; font-weight: bold; display: none;">üìç Siguiendo</div>
                    <div class="connect-status" style="font-size: 12px; font-weight: bold; color: green;">üì∂ Conectado</div>
                </div>
                
            `;

        //-------------------------------------------

        // ‚úÖ Enganche bloqueado si est√° desconectado
        div.addEventListener("click", () => {
          const estadoActual = estadoUsuarios.get(user.id);
          const desconectado =
            estadoActual?.ciclosSinCambio >= MAX_CICLOS_SIN_CAMBIO;

          if (desconectado) {
            debug(
              `üö´ Usuario ${user.id} est√° desconectado. Enganche desde createUserMarker() bloqueado.`
            );
            return;
          }

          const yaEnganchado = camaraEnganchadaA === user.id;

          if (camaraEnganchadaA !== null) {
            const anterior = document.getElementById(
              `user-panel-${camaraEnganchadaA}`
            );
            if (anterior) {
              anterior.classList.remove("selected");
              const textoAnterior = anterior.querySelector(".follow-status");
              if (textoAnterior) textoAnterior.style.display = "none";
            }
          }

          if (yaEnganchado) {
            camaraEnganchadaA = null;
            debug(`üîì C√°mara desenganchada`);
          } else {
            camaraEnganchadaA = user.id;
            div.classList.add("selected");
            const texto = div.querySelector(".follow-status");
            if (texto) texto.style.display = "block";

            if (!cameraMoving) {
              moveCamera(
                marker.position.x,
                marker.position.y,
                marker.position.z
              );
              ultimaPosicionCamara.set(user.id, {
                x: marker.position.x,
                y: marker.position.y,
                z: marker.position.z,
              });
            }

            debug(`üìå C√°mara enganchada a Usuario ${user.id}`);
          }
        });

        const panel = document.getElementById("points-panel-content");
        panel.appendChild(div);

        return marker;
      }

      //---------------------------------------------------------------------------------

      function crearFlechaDireccion(user, posicion) {
        const headingRad = user.heading * (Math.PI / 180);

        // Crear grupo
        const grupo = new THREE.Group();

        // üü¢ Anillo centrado en el punto GPS
        const ringGeometry = new THREE.RingGeometry(2.1, 2.4, 32); // radio reducido
        const materialAnillo = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.35,
          side: THREE.DoubleSide,
          depthTest: false,
        });

        const anillo = new THREE.Mesh(ringGeometry, materialAnillo);
        grupo.add(anillo); // sin rotaci√≥n

        // üî∫ Flecha sobre el borde del anillo
        const shape = new THREE.Shape();
        shape.moveTo(0, 0.2);
        shape.lineTo(0.1, -0.2);
        shape.lineTo(0, -0.1);
        shape.lineTo(-0.1, -0.2);
        shape.lineTo(0, 0.2);
        const geometry = new THREE.ShapeGeometry(shape);

        const matFlecha = new THREE.MeshBasicMaterial({
          color: user.color,
          side: THREE.DoubleSide,
        });

        const flecha = new THREE.Mesh(geometry, matFlecha);
        flecha.scale.set(1.7, 1.7, 1); // Escalado uniforme (ligeramente m√°s grande que antes)

        flecha.position.y = 2.25; // borde exacto del anillo reducido
        grupo.add(flecha);

        // üìç Centrar el grupo en el punto GPS
        grupo.position.copy(posicion);
        grupo.rotation.z = -headingRad;

        viewer.scene.scene.add(grupo);
        return grupo;
      }

      //---------------------------------------------------------------------------------

      function actualizarUsuariosDesdeAWS(positions) {
        const idsRecibidos = new Set();

        positions.forEach((datos) => {
          const id = datos.id;
          const timestampActual = datos.timestamp || Date.now() / 1000;

          if (!estadoUsuarios.has(id)) {
            estadoUsuarios.set(id, {
              ultimoTimestamp: timestampActual,
              ciclosSinCambio: 0,
            });
          } else {
            const estado = estadoUsuarios.get(id);
            if (estado.ultimoTimestamp === timestampActual) {
              estado.ciclosSinCambio++;
            } else {
              estado.ultimoTimestamp = timestampActual;
              estado.ciclosSinCambio = 0;
            }
          }

          const estado = estadoUsuarios.get(id);
          const desconectado = estado.ciclosSinCambio >= MAX_CICLOS_SIN_CAMBIO;
          const purgarVisualmente =
            estado.ciclosSinCambio >= MAX_CICLOS_SIN_CAMBIO + 5; // solo limpieza visual

          const cloud = convertGPSToCloudCoords(
            datos.lat,
            datos.lon,
            datos.alt
          );
          if (!cloud || isNaN(cloud.x) || isNaN(cloud.y) || isNaN(cloud.z)) {
            console.warn(`Coordenadas inv√°lidas para usuario ${id}, se omite.`);
            return;
          }

          let fueraDeRango = false;
          if (limitesCuboDinamico) {
            const { center, size, rotZ } = limitesCuboDinamico;
            const cosZ = Math.cos(-rotZ);
            const sinZ = Math.sin(-rotZ);
            const dx = cloud.x - center.x;
            const dy = cloud.y - center.y;
            const localX = dx * cosZ - dy * sinZ;
            const localY = dx * sinZ + dy * cosZ;
            const localZ = cloud.z - center.z;
            fueraDeRango =
              Math.abs(localX) > size.x / 2 ||
              Math.abs(localY) > size.y / 2 ||
              Math.abs(localZ) > size.z / 2;
          }

          if (desconectado) {
            if (userMarkers[id]) {
              viewer.scene.scene.remove(userMarkers[id]);
              delete userMarkers[id];
            }
            if (flechasHeading[id]) {
              viewer.scene.scene.remove(flechasHeading[id]);
              delete flechasHeading[id];
            }

            if (camaraEnganchadaA === id) {
              camaraEnganchadaA = null;
              debug(
                `üîì C√°mara desenganchada porque el usuario ${id} se desconect√≥.`
              );
            }
          }

          if (fueraDeRango && userMarkers[id]) {
            userMarkers[id].visible = false;
            if (camaraEnganchadaA === id) {
              camaraEnganchadaA = null;
              debug(
                `üîì C√°mara desenganchada porque el usuario ${id} est√° fuera de rango.`
              );
            }
          }

          let user = userLocations.get(id);
          if (!user) {
            const colores = [
              "#ff0000",
              "#00ff00",
              "#0000ff",
              "#ffff00",
              "#00ffff",
              "#ff00ff",
            ];
            const color = colores[userLocations.size % colores.length];
            user = {
              id,
              lat: datos.lat,
              lon: datos.lon,
              alt: datos.alt,
              speed: datos.speed,
              heading: datos.heading,
              color,
            };
            userLocations.set(id, user);
          } else {
            user.lat = datos.lat;
            user.lon = datos.lon;
            user.alt = datos.alt;
            user.speed =
              typeof datos.speed === "number" ? datos.speed : undefined;
            user.heading =
              typeof datos.heading === "number" ? datos.heading : undefined;
          }

          user.fueraDeRango = fueraDeRango;

          idsRecibidos.add(id);

          if (!trayectoriasPorUsuario.has(id))
            trayectoriasPorUsuario.set(id, []);
          const trayectoria = trayectoriasPorUsuario.get(id);
          trayectoria.push({ x: cloud.x, y: cloud.y, z: cloud.z });

          if (!userMarkers[id] && !desconectado && !fueraDeRango) {
            userMarkers[id] = createUserMarker(
              cloud.x,
              cloud.y,
              cloud.z,
              user,
              cloud
            );
            // üß≠ Mostrar flecha de orientaci√≥n si hay heading
            if (!isNaN(user.heading)) {
              const pos = new THREE.Vector3(cloud.x, cloud.y, cloud.z);

              if (flechasHeading[id]) {
                flechasHeading[id].position.copy(pos);
                flechasHeading[id].position.z += 3;
                flechasHeading[id].rotation.z = -user.heading * (Math.PI / 180);
              } else {
                const flecha = crearFlechaDireccion(user, pos);
                flechasHeading[id] = flecha;
              }
            } else {
              if (flechasHeading[id]) {
                viewer.scene.scene.remove(flechasHeading[id]);
                delete flechasHeading[id];
              }
            }
          } else if (userMarkers[id] && !fueraDeRango) {
            userMarkers[id].position.set(cloud.x, cloud.y, cloud.z);
            userMarkers[id].visible = true;
          }

          if (
            camaraEnganchadaA === id &&
            !cameraMoving &&
            !desconectado &&
            !fueraDeRango
          ) {
            const ultima = ultimaPosicionCamara.get(id);
            const nueva = { x: cloud.x, y: cloud.y, z: cloud.z };
            const delta = ultima
              ? Math.abs(ultima.x - nueva.x) +
                Math.abs(ultima.y - nueva.y) +
                Math.abs(ultima.z - nueva.z)
              : Infinity;

            if (delta > 0.1) {
              moveCamera(nueva.x, nueva.y, nueva.z);
              ultimaPosicionCamara.set(id, nueva);
              debug(`üì° C√°mara actualizada al moverse el usuario ${id}`);
            }
          }

          if (trayectoria.length >= 2) {
            const ultima = trayectoria[trayectoria.length - 1];
            const penultima = trayectoria[trayectoria.length - 2];
            const igual =
              ultima.x === penultima.x &&
              ultima.y === penultima.y &&
              ultima.z === penultima.z;
            if (!igual) {
              const puntos = trayectoria.map(
                (p) => new THREE.Vector3(p.x, p.y, p.z + 2)
              );
              const curva = new THREE.CatmullRomCurve3(puntos);
              const geometry = new THREE.TubeGeometry(
                curva,
                100,
                0.2,
                8,
                false
              );
              const material = new THREE.MeshBasicMaterial({
                color: user.color,
                transparent: true,
                opacity: 1.0,
              });

              let linea = trayectoriasLineas.get(id);
              const visibleAntes = linea?.visible ?? true;

              if (linea) {
                viewer.scene.scene.remove(linea);
                linea.geometry.dispose();
                linea.material.dispose();
              }

              linea = new THREE.Mesh(geometry, material);
              linea.visible = visibleAntes;
              viewer.scene.scene.add(linea);
              trayectoriasLineas.set(id, linea);
            }
          }

          const panelContenedor = document.getElementById(
            "points-panel-content"
          );
          const oldPanel = document.getElementById(`user-panel-${id}`);
          if (oldPanel) oldPanel.remove();

          const div = document.createElement("div");
          div.className = "point-item";
          div.id = `user-panel-${id}`;
          div.style.borderColor = user.color;

          const velocidadTexto = user.speed
            ? `Velocidad: ${user.speed.toFixed(3)} m/s<br>`
            : "";
          const rumboTexto = user.heading
            ? `Rumbo: ${headingToCompass(user.heading)}<br>`
            : "";

          let estadoTexto = desconectado ? "üì∂ Desconectado" : "üì∂ Conectado";
          let colorEstado = desconectado ? "gray" : "green";

          if (!desconectado && fueraDeRango) {
            estadoTexto += "<br>üì° Fuera de Rango";
            colorEstado = "orange";
          }

          div.innerHTML = `
                    <div class="point-icon" style="background-color: ${
                      user.color
                    };"></div>
                    <div class="point-details">
                        <div class="point-title">Usuario ${id}</div>
                        <div class="point-coords">
                            Lat: ${decimalToDMS(user.lat, true)}<br>
                            Lon: ${decimalToDMS(user.lon, false)}<br>
                            Alt: ${user.alt.toFixed(2)} m<br>
                            ${velocidadTexto}
                            ${rumboTexto}
                            <small>Nube: X=${cloud.x.toFixed(
                              2
                            )}, Y=${cloud.y.toFixed(2)}, Z=${cloud.z.toFixed(
            2
          )}</small>
                        </div>
                        <div class="follow-status" style="font-size: 12px; color: green; font-weight: bold; display: ${
                          camaraEnganchadaA === id ? "block" : "none"
                        };">üìç Siguiendo</div>
                        <div class="connect-status" style="font-size: 12px; font-weight: bold; color: ${colorEstado};">${estadoTexto}</div>
                        ${
                          desconectado
                            ? `<div class='purge-bar' style='width: 100%; background: #ddd; height: 6px; margin-top: 4px;'>
                            <div style='height: 100%; background: orange; width: ${(
                              (100 *
                                (estado.ciclosSinCambio -
                                  MAX_CICLOS_SIN_CAMBIO)) /
                              5
                            ).toFixed(0)}%; transition: width 0.3s;'></div>
                        </div>`
                            : ""
                        }
                    </div>`;

          div.addEventListener("click", () => {
            const bloqueado = desconectado || fueraDeRango;
            if (bloqueado) {
              const motivo = desconectado ? "desconectado" : "fuera de rango";
              debug(`üö´ Usuario ${id} est√° ${motivo}. Enganche bloqueado.`);
              return;
            }

            const yaEnganchado = camaraEnganchadaA === id;
            if (camaraEnganchadaA !== null) {
              const anterior = document.getElementById(
                `user-panel-${camaraEnganchadaA}`
              );
              if (anterior) {
                anterior.classList.remove("selected");
                const txt = anterior.querySelector(".follow-status");
                if (txt) txt.style.display = "none";
              }
            }

            if (yaEnganchado) {
              camaraEnganchadaA = null;
              debug(`üîì C√°mara desenganchada`);
            } else {
              camaraEnganchadaA = id;
              div.classList.add("selected");
              const txt = div.querySelector(".follow-status");
              if (txt) txt.style.display = "block";

              const marcador = userMarkers[id];
              if (marcador && !cameraMoving) {
                moveCamera(
                  marcador.position.x,
                  marcador.position.y,
                  marcador.position.z
                );
                ultimaPosicionCamara.set(id, {
                  x: marcador.position.x,
                  y: marcador.position.y,
                  z: marcador.position.z,
                });
              }
              debug(`üìå C√°mara enganchada a Usuario ${id}`);
            }
          });

          if (camaraEnganchadaA === id) {
            div.classList.add("selected");
          }

          if (purgarVisualmente) {
            if (userMarkers[id]) {
              viewer.scene.scene.remove(userMarkers[id]);
              delete userMarkers[id];
            }
            if (flechasHeading[id]) {
              viewer.scene.scene.remove(flechasHeading[id]);
              delete flechasHeading[id];
            }

            const panel = document.getElementById(`user-panel-${id}`);
            if (panel) panel.remove();

            if (trayectoriasLineas.has(id)) {
              const linea = trayectoriasLineas.get(id);
              viewer.scene.scene.remove(linea);
              linea.geometry.dispose();
              linea.material.dispose();
              trayectoriasLineas.delete(id);
            }

            trayectoriasPorUsuario.delete(id);

            if (camaraEnganchadaA === id) {
              camaraEnganchadaA = null;
              debug(
                `üîì C√°mara desenganchada porque el usuario ${id} fue limpiado visualmente.`
              );
            }

            return;
          }

          panelContenedor.appendChild(div);
        });

        // üîí Forzar cierre y deshabilitado del panel si no hay cajas visibles
        const contenedorPanel = document.getElementById("points-panel");
        const contenidoPanel = document.getElementById("points-panel-content");
        const toggleBtn = document.getElementById("toggle-panel");

        if (contenedorPanel && contenidoPanel) {
          const hayCajas = contenidoPanel.children.length > 0;

          if (!hayCajas) {
            contenedorPanel.classList.add("panel-collapsed");
            if (toggleBtn) {
              toggleBtn.textContent = "‚â´";
              toggleBtn.disabled = true;
            }
            isPanelCollapsed = true;
            debug(
              "üìÅ Panel cerrado autom√°ticamente porque no hay usuarios visibles."
            );
          } else {
            if (toggleBtn) toggleBtn.disabled = false;
          }
        }
      }

      //----------------------------------------------------------------------------------

      const VENTANA_TIEMPO_SEGUNDOS = 120; // 2 minutos de ventana m√≥vil
      const MAX_PUNTOS = 10; // Fallback si no hay puntos recientes

      async function cargarDesdeAWS() {
        if (!gpsDB) return;

        try {
          const deviceIds = await listarDeviceIds(); // Paso nuevo

          const ahora = Date.now();
          const VENTANA_TIEMPO_SEGUNDOS = 120;
          const MAX_PUNTOS = 10;

          const datosFormateados = [];

          //--------------------------
          for (const id of deviceIds) {
            const posiciones = await gpsDB.getPositionsByDevice(id, 10);
            if (!posiciones || posiciones.length === 0) continue;

            const ahora = Date.now();
            const VENTANA_TIEMPO_SEGUNDOS = 120;
            const MAX_PUNTOS = 10;

            const recientes = posiciones.filter(
              (p) =>
                ahora - p.timestamp * 1000 <= VENTANA_TIEMPO_SEGUNDOS * 1000
            );
            const usados =
              recientes.length >= 2 ? recientes : posiciones.slice(-MAX_PUNTOS);

            // Seleccionar punto m√°s reciente con datos √∫tiles
            const ultima =
              [...usados]
                .reverse()
                .find((p) => p.custom && typeof p.custom.speed === "number") ||
              usados[usados.length - 1];

            if (!ultima) continue;

            const custom = ultima.custom || {};

            // Mostrar tabla de los 5 √∫ltimos puntos, resaltando cu√°l fue seleccionado
            console.group(`üì¶ Datos descargados para ${id}`);
            const tabla = usados.slice(-5).map((p) => ({
              timestamp: p.timestamp,
              lat: p.latitude,
              lon: p.longitude,
              alt: p.altitude,
              speed: p.custom?.speed,
              heading: p.custom?.heading,
              "‚úÖ Seleccionado": p === ultima ? "‚úÖ" : "",
            }));
            console.table(tabla);
            console.groupEnd();

            // Armar datos para actualizar panel lateral
            datosFormateados.push({
              id: ultima.id,
              lat: ultima.latitude,
              lon: ultima.longitude,
              alt: ultima.altitude,
              timestamp: ultima.timestamp,
              speed:
                typeof custom.speed === "number" ? custom.speed : undefined,
              heading:
                typeof custom.heading === "number" ? custom.heading : undefined,
            });
          }

          //------------------------
          actualizarUsuariosDesdeAWS(datosFormateados); // Ya tienes esta funci√≥n
        } catch (err) {
          console.error("‚ùå Error al cargar posiciones desde AWS:", err);
        }
      }

      //
      // Funci√≥n para actualizar el panel desplegable con los datos del punto
      function updatePointPanel(x, y, z, lat, lon, alt) {
        debug("Actualizando panel de puntos GPS...");

        try {
          const pointContent = document.getElementById("points-panel-content");

          // Convertir coordenadas decimales a formato DMS
          const latDMS = decimalToDMS(lat, true);
          const lonDMS = decimalToDMS(lon, false);

          // Crear o actualizar el contenido del panel
          pointContent.innerHTML = `
                    <div class="point-item" style="cursor: pointer;" title="Centrar c√°mara en este punto">
                        <div class="point-icon"></div>
                        <div class="point-details">
                            <div class="point-title">Posici√≥n GPS</div>
                            <div class="point-coords">
                                Lat: ${latDMS}<br>
                                Lon: ${lonDMS}<br>
                                Alt: ${alt.toFixed(2)} m<br>
                                <small>Nube: X=${x.toFixed(2)}, Y=${y.toFixed(
            2
          )}, Z=${z.toFixed(2)}</small>
                            </div>
                        </div>
                    </div>
                `;

          const pointItem = pointContent.querySelector(".point-item");
          pointItem.addEventListener("click", () => {
            debug("Panel clickeado, centrando c√°mara en punto GPS...");
            if (!cameraMoving) {
              moveCamera(x, y, z);
            } else {
              alert("La c√°mara ya se est√° moviendo. Por favor espere...");
            }
          });

          debug("Panel de puntos GPS actualizado");
        } catch (error) {
          debug(`ERROR al actualizar panel de puntos: ${error.message}`);
          console.error("Error al actualizar panel de puntos:", error);
        }
      }

      // Funci√≥n para mover la c√°mara de forma suave con pasos intermedios
      function moveCamera(
        x,
        y,
        z,
        targetX = x,
        targetY = y,
        targetZ = z,
        usarOffset = true
      ) {
        if (!pointcloud || cameraMoving) return;

        const camera = viewer.scene.getActiveCamera();
        const currentPos = camera.position.clone();
        const currentTarget = viewer.scene.view.getPivot().clone();

        const newTarget = new THREE.Vector3(targetX, targetY, targetZ);
        const distancia = newTarget.distanceTo(currentTarget);

        if (distancia < 0.5) {
          debug("üõë Movimiento insignificante. C√°mara no se mover√°.");
          cameraMoving = false;
          return;
        }

        debug(
          `üéØ Moviendo c√°mara hacia (${x}, ${y}, ${z}), con enfoque en (${targetX}, ${targetY}, ${targetZ})`
        );

        cameraMoving = true;

        let newPos;

        if (usarOffset) {
          const offset = new THREE.Vector3(30, 30, 40);
          newPos = newTarget.clone().add(offset);
        } else {
          newPos = new THREE.Vector3(x, y, z); // usar posici√≥n directa sin offset
        }

        const numSteps = 20;
        const duration = 2000;
        const stepInterval = duration / numSteps;
        let currentStep = 0;

        function moveStep() {
          if (currentStep >= numSteps) {
            cameraMoving = false;
            debug("‚úÖ Movimiento de c√°mara completado");
            viewer.scene.dispatchEvent({ type: "update" });
            viewer.scene.dispatchEvent({ type: "pointclouds_loaded" });
            return;
          }

          const progress = (currentStep + 1) / numSteps;
          const lerpPos = new THREE.Vector3().lerpVectors(
            currentPos,
            newPos,
            progress
          );
          const lerpTarget = new THREE.Vector3().lerpVectors(
            currentTarget,
            newTarget,
            progress
          );

          viewer.scene.view.setView(
            [lerpPos.x, lerpPos.y, lerpPos.z],
            [lerpTarget.x, lerpTarget.y, lerpTarget.z]
          );

          currentStep++;
          setTimeout(moveStep, stepInterval);
        }

        moveStep();
      }

      //-----------------------------------------------------------------------------

      class GPSDatabase {
        constructor(tableName = "locations") {
          if (!window.awsConfig) {
            throw new Error("awsConfig no est√° definido.");
          }

          AWS.config.update({
            region: window.awsConfig.region,
            accessKeyId: window.awsConfig.accessKeyId,
            secretAccessKey: window.awsConfig.secretAccessKey,
          });

          this.tableName = tableName;
          this.docClient = new AWS.DynamoDB.DocumentClient();
        }

        async getPositionsByDevice(deviceId, count = 100) {
          try {
            const params = {
              TableName: this.tableName,
              KeyConditionExpression: "#d = :deviceId",
              ExpressionAttributeNames: {
                "#d": "deviceId",
              },
              ExpressionAttributeValues: {
                ":deviceId": deviceId,
              },
              Limit: count,
              ScanIndexForward: false,
            };

            const data = await this.docClient.query(params).promise();
            return data.Items.map((item) => ({
              id: item.deviceId,
              timestamp: item.timestamp,
              latitude: item.latitude,
              longitude: item.longitude,
              altitude: item.altitude,
              custom:
                typeof item.custom === "object" && item.custom !== null
                  ? item.custom
                  : {},
            }));
          } catch (error) {
            console.error(
              `‚ùå Error al obtener posiciones de ${deviceId}:`,
              error
            );
            return [];
          }
        }
      }

      //-----------------------------------------------------------------------------

      async function listarDeviceIds() {
        try {
          const params = {
            TableName: "locations",
            ProjectionExpression: "deviceId",
          };

          const data = await gpsDB.docClient.scan(params).promise();

          const idsUnicos = [
            ...new Set(data.Items.map((item) => item.deviceId)),
          ];
          console.log("üìã Device IDs encontrados:", idsUnicos);
          return idsUnicos;
        } catch (error) {
          console.error("‚ùå Error al listar deviceIds:", error);
          return [];
        }
      }

      // Crear un marcador para el punto de referencia
      function createReferenceMarker() {
        if (!cloudLoaded) return;

        debug("Creando marcador para el punto de referencia...");

        try {
          // Crear un cubo para el punto de referencia
          const cubeGeometry = new THREE.BoxGeometry(3, 3, 3);
          const cubeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
          referenceMarker = new THREE.Mesh(cubeGeometry, cubeMaterial);

          // Colocar en el punto de referencia exacto
          referenceMarker.position.set(
            referencePoint.cloud.x,
            referencePoint.cloud.y,
            referencePoint.cloud.z
          );

          // A√±adir a la escena
          viewer.scene.scene.add(referenceMarker);
          debug(
            "Marcador de referencia creado (cubo verde en aleta de tibur√≥n)"
          );
        } catch (error) {
          debug(`ERROR al crear marcador de referencia: ${error.message}`);
          console.error("Error al crear marcador de referencia:", error);
        }
      }

      //-------------------------------------------------------------------------------

      viewer.loadGUI(() => {
        debug("GUI de Potree cargada");
        viewer.setLanguage("en");

        // Ocultar sidebar al inicio
        viewer.toggleSidebar();
        debug("Sidebar ocultada");

        // Ocultar todas las herramientas excepto las especificadas
        const toolsToKeep = ["full_extent"];

        // Recorrer todas las herramientas y ocultar las que no est√°n en la lista
        for (let key in viewer.measuringTool) {
          if (!toolsToKeep.includes(key)) {
            try {
              viewer.measuringTool[key].element.style.display = "none";
            } catch (e) {
              debug(`No se pudo ocultar la herramienta: ${key}`);
            }
          }
        }

        // Tambi√©n intentar ocultar elementos del men√∫ que no necesitamos
        setTimeout(() => {
          try {
            // Ocultar elementos de men√∫ no necesarios
            document
              .querySelectorAll(
                "#potree_sidebar_container .potree_menu_buttons li"
              )
              .forEach((item) => {
                if (!item.classList.contains("full_extent")) {
                  item.style.display = "none";
                }
              });
            debug("Herramientas innecesarias ocultadas");
          } catch (e) {
            debug(`Error al ocultar elementos de men√∫: ${e.message}`);
          }
        }, 1000);

        // Ocultar completamente el sidebar de Potree
        document.getElementById("potree_sidebar_container").style.display =
          "none";
        debug("Panel lateral de Potree completamente ocultado");
      });

      //----------------------------------M1.1---------------------------------------------------

      Potree.loadPointCloud("pointclouds/Nube1/cloud.js", "Nube1", (e) => {
        debug("Cargando nube de puntos...");
        pointcloud = e.pointcloud;

        requestAnimationFrame(function esperarCarga() {
          const puntos = viewer.scene.numPoints;

          if (puntos >= MAX_PUNTOS_CARGA) {
            const pantalla = document.getElementById("loading-screen");
            pantalla.style.opacity = 0;
            setTimeout(() => (pantalla.style.display = "none"), 500);
          } else {
            requestAnimationFrame(esperarCarga);
          }
        });

        let material = pointcloud.material;
        viewer.scene.addPointCloud(pointcloud);

        debug("Nube de puntos a√±adida a la escena");

        // Determinar la altura m√≠nima de la nube
        try {
          const boundingBox = pointcloud.boundingBox;
          minCloudHeight = boundingBox.min.z;
          debug(`Altura m√≠nima de la nube detectada: ${minCloudHeight}`);
        } catch (error) {
          debug(`Error al determinar altura m√≠nima: ${error.message}`);
          // Usar un valor predeterminado si no se puede determinar
          minCloudHeight = 0;
        }

        //-------------------------------------------------------------------------------

        debug("Nube de puntos a√±adida a la escena");

        // Configuraci√≥n fija para la visualizaci√≥n de intensidad
        material.activeAttributeName = "intensity";
        material.size = 1;

        // MODIFICACI√ìN: Reactivar renderizado adaptativo
        material.pointSizeType = Potree.PointSizeType.ADAPTIVE; // Cambiar de FIXED a ADAPTIVE
        material.shape = Potree.PointShape.SQUARE;

        // Configuraci√≥n espec√≠fica para la intensidad
        material.intensityRange = [0, 255];
        material.intensityGamma = 0.43;
        material.intensityBrightness = 0.03;
        material.intensityContrast = -0.06;

        // Ajustes de nivel de detalle (LOD) para optimizar la carga
        pointcloud.minNodeSize = 50; // Reduce de 100 a 50 para mayor detalle a distancia
        pointcloud.maxNodeSize = 300; // Tama√±o m√°ximo de nodo a cargar
        pointcloud.progressiveRendering = true; // Activar renderizado progresivo
        viewer.setPointBudget(2_000_000); // Volver a 2M puntos para equilibrar rendimiento

        debug("Configuraci√≥n de visualizaci√≥n de intensidad aplicada");

        // MODIFICACI√ìN: Forzar carga completa de la nube
        pointcloud.showBoundingBox = true; // Mostrar el cuadro delimitador
        pointcloud.generateDEM = false; // Desactivar generaci√≥n DEM que podr√≠a afectar rendimiento

        viewer.fitToScreen();
        debug("Ajustando vista a pantalla completa");

        const cam = viewer.scene.getActiveCamera();
        const target = viewer.scene.view.getPivot();
        const enfoque = new THREE.Vector3()
          .subVectors(target, cam.position)
          .normalize();
        debug(
          `üéØ Direcci√≥n inicial de la c√°mara: (${enfoque.x.toFixed(
            3
          )}, ${enfoque.y.toFixed(3)}, ${enfoque.z.toFixed(3)})`
        );

        // Inicializar el administrador de anotaciones
        annotations = viewer.scene.annotations;
        debug("Administrador de anotaciones inicializado");

        // Marcar que la nube est√° cargada
        cloudLoaded = true;

        // Crear el marcador de referencia
        createReferenceMarker();

        crearPlanoBoundingBox(); // ‚ö†Ô∏è Esto inicializa la caja invisible pero activa sus l√≠mites
        planoBoundingBox.visible = false;
        viewer.scene.scene.children.forEach((obj) => {
          if (
            obj.type === "LineSegments" &&
            obj.geometry instanceof THREE.EdgesGeometry
          ) {
            obj.visible = false;
          }
        });
        debug(
          "üî≤ Bounding box creada autom√°ticamente al inicio (invisible pero funcional)"
        );

        const POSICION_HOGAR = new THREE.Vector3(
          524771.285943634,
          1215882.4076521,
          69.51156807146481
        );
        const FOCO_HOGAR = new THREE.Vector3(524823.59, 1215810.79, 31.98);

        moveCamera(
          POSICION_HOGAR.x,
          POSICION_HOGAR.y,
          POSICION_HOGAR.z,
          FOCO_HOGAR.x,
          FOCO_HOGAR.y,
          FOCO_HOGAR.z,
          false
        );
        debug(
          "üéØ C√°mara inicial enviada al punto hogar calibrado con transici√≥n suave"
        );

        try {
          gpsDB = new GPSDatabase("locations");
          debug("Base de datos AWS inicializada correctamente.");
        } catch (err) {
          console.error("Error al inicializar la base de datos AWS:", err);
          alert("No se pudo conectar con AWS. Verifica la consola.");
        }

        // Comenzar la escucha autom√°tica al servidor AWS
        setInterval(() => {
          cargarDesdeAWS();
        }, 10000); // cada 10 segundos

        // Usar la primera coordenada de la matriz como punto inicial
        for (const [id, user] of userLocations) {
          if (user.lat != null && user.lon != null && user.alt != null) {
            const cloud = convertGPSToCloudCoords(user.lat, user.lon, user.alt);
            if (!cloud) continue;
            const marker = createUserMarker(cloud.x, cloud.y, cloud.z, user);
            userMarkers[id] = marker;
          }
        }

        // Agregar manejadores de eventos para la nube
        pointcloud.addEventListener("visibility_changed", (e) => {
          debug(
            `Visibilidad de la nube cambiada: ${
              e.visible ? "visible" : "invisible"
            }`
          );

          // Si se vuelve invisible durante el renderizado adaptativo
          if (!e.visible && !cameraMoving) {
            setTimeout(() => {
              pointcloud.visible = true;
              debug("Restaurando visibilidad con renderizado adaptativo");

              // Ajustar temporalmente a menos puntos para recuperar visibilidad m√°s r√°pido
              const currentBudget = viewer.getPointBudget();
              viewer.setPointBudget(Math.min(500000, currentBudget));

              // Restaurar presupuesto original despu√©s de recuperar visibilidad
              setTimeout(() => {
                viewer.setPointBudget(currentBudget);
                debug("Restaurando presupuesto de puntos original");
              }, 500);
            }, 100);
          }
        });
        //----------------------------------------------------------------------
      });

      // Variable para almacenar la altura m√≠nima de la nube
      let minCloudHeight = null;

      viewer.addEventListener("update", function () {
        if (!cloudLoaded || !pointcloud) return;

        // Comprobar si la nube est√° visible
        const isVisible = pointcloud.visible;
        if (!isVisible) {
          debug("ADVERTENCIA: La nube de puntos no es visible actualmente");

          // Reintentar hacer visible la nube
          pointcloud.visible = true;
          viewer.scene.view.setPointCloudsVisible(true);
        }

        // Limitar la altura m√≠nima de la c√°mara
        if (minCloudHeight !== null) {
          const camera = viewer.scene.getActiveCamera();
          if (camera && camera.position.z < minCloudHeight + 5) {
            debug(`Limitando c√°mara a altura m√≠nima: ${minCloudHeight + 5}`);
            camera.position.z = minCloudHeight + 5;
            viewer.scene.view.update(
              viewer.scene.getActiveCamera(),
              viewer.scene.pointclouds
            );
          }
        }
        actualizarBrujulaSegunCamara();

        // üîÅ Animar flechas de heading (latido)
        for (const id in flechasHeading) {
          const grupo = flechasHeading[id];
          if (!grupo) continue;

          // Buscar la flecha dentro del grupo
          const flecha = grupo.children.find(
            (obj) => obj.geometry && obj.geometry.type === "ShapeGeometry"
          );

          if (flecha) {
            const t = performance.now() * 0.0035;
            const base = 3.5;
            const intensidad = 1.5;
            const scale = base + intensidad * Math.sin(t);
            flecha.scale.set(scale, scale, 1);
          }
        }
      });

      // Funcionalidad adicional para ajustar la vista si hay problemas

      function resetView() {
        if (!cloudLoaded) {
          debug("No se puede reiniciar la vista - la nube no est√° cargada");
          return;
        }

        debug("Reiniciando vista de la nube...");

        try {
          // Forzar visibilidad
          if (pointcloud) {
            pointcloud.visible = true;
          }

          // Evitar error: primero desactivar cualquier animaci√≥n pendiente
          if (cameraMoving) {
            cameraMoving = false;
            debug("Cancelando movimiento de c√°mara previo");
          }

          // Esperar un momento para asegurar que animaciones anteriores hayan terminado
          setTimeout(() => {
            try {
              // MODIFICACI√ìN: Usar las coordenadas del marcador GPS si existe
              if (gpsMarker) {
                const pos = gpsMarker.position;
                debug(
                  `Centrando vista en marcador GPS (${pos.x.toFixed(
                    2
                  )}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})`
                );

                // Establecer vista desde una posici√≥n elevada mirando al marcador GPS
                const safePosition = [pos.x + 50, pos.y + 50, pos.z + 50];
                const targetPosition = [pos.x, pos.y, pos.z];

                viewer.scene.view.setView(safePosition, targetPosition);
              } else {
                // Si no hay marcador GPS, usar el punto de referencia como respaldo
                debug("No hay marcador GPS, usando punto de referencia");
                const safePosition = [
                  referencePoint.cloud.x + 50,
                  referencePoint.cloud.y + 50,
                  referencePoint.cloud.z + 50,
                ];
                const targetPosition = [
                  referencePoint.cloud.x,
                  referencePoint.cloud.y,
                  referencePoint.cloud.z,
                ];

                viewer.scene.view.setView(safePosition, targetPosition);
              }

              // Asegurar que todas las nubes de puntos est√©n visibles
              viewer.scene.view.setPointCloudsVisible(true);

              // Forzar una actualizaci√≥n del renderizado
              viewer.scene.dispatchEvent({ type: "update" });

              // Ajustar suavemente la vista despu√©s de un breve retraso
              setTimeout(() => {
                try {
                  // Forzar actualizaci√≥n
                  viewer.scene.dispatchEvent({ type: "update" });
                  viewer.scene.dispatchEvent({ type: "pointclouds_loaded" });

                  // Ejecutar la funci√≥n de estabilizaci√≥n
                  stabilizeView();
                } catch (innerError) {
                  debug(`Error en resetView: ${innerError.message}`);
                }
              }, 500);
            } catch (delayedError) {
              debug(
                `Error durante el reinicio retrasado: ${delayedError.message}`
              );
            }
          }, 100);
        } catch (error) {
          debug(`ERROR al reiniciar vista: ${error.message}`);
          console.error("Error al reiniciar vista:", error);
        }
      }

      //-----------------------------------------------------------------------------

      // Funci√≥n auxiliar para estabilizar la vista despu√©s de fitToScreen
      function stabilizeView() {
        if (!cloudLoaded || !pointcloud) return;

        // Restaurar visibilidad y forzar actualizaci√≥n
        pointcloud.visible = true;
        viewer.scene.view.setPointCloudsVisible(true);

        // Ciclo de actualizaci√≥n progresiva
        const updateSequence = [100, 300, 600];
        updateSequence.forEach((delay) => {
          setTimeout(() => {
            viewer.scene.dispatchEvent({ type: "update" });
            viewer.scene.dispatchEvent({ type: "pointclouds_loaded" });
            debug(`Actualizaci√≥n estabilizadora a ${delay}ms`);
          }, delay);
        });
      }

      // Agregar controlador para teclas de teclado (para debugging)
      document.addEventListener("keydown", function (event) {
        // Tecla 'R' para resetear la vista
        if (event.key === "r" || event.key === "R") {
          resetView();
        }
        // Tecla 'B' para mostrar/ocultar plano de bounding box
        if (event.key === "b" || event.key === "B") {
          togglePlanoBoundingBox();
        }
        // Movimiento alineado con orientaci√≥n visual del cubo rotado 45¬∞
        if (event.key === "w") moverCuboEnDireccion(5, 45); // hacia arriba en pantalla
        if (event.key === "s") moverCuboEnDireccion(5, 225); // abajo
        if (event.key === "a") moverCuboEnDireccion(5, 135); // izquierda visual
        if (event.key === "d") moverCuboEnDireccion(5, -45); // derecha visual

        if (event.key === "i" || event.key === "I") {
          mostrarDimensionesYCentroDelCubo();
        }
      });

      //-----------------------------M4------------------------------------

      // Funci√≥n para verificar y recuperar la visibilidad de la nube
      function checkAndRestoreCloudVisibility() {
        if (!cloudLoaded || !pointcloud) return;

        if (!pointcloud.visible) {
          debug("Detectada p√©rdida de visibilidad - intentando recuperar");
          pointcloud.visible = true;
          viewer.scene.view.setPointCloudsVisible(true);

          // Forzar actualizaci√≥n de nivel de detalle
          viewer.scene.dispatchEvent({ type: "pointclouds_loaded" });

          // Ajustar la vista cerca del marcador actual si existe
          if (gpsMarker) {
            const pos = gpsMarker.position;
            debug(
              `Reposicionando cerca del marcador (${pos.x.toFixed(
                2
              )}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})`
            );

            // Usar una posici√≥n ligeramente diferente para forzar actualizaci√≥n
            viewer.scene.view.setView(
              [pos.x + 10, pos.y + 10, pos.z + 30],
              [pos.x, pos.y, pos.z]
            );
          } else {
            // Si no hay marcador, reset completo
            resetView();
          }
        }
      }

      function actualizarBrujulaSegunCamara() {
        const arrow = document.getElementById("north-arrow");
        if (!arrow || !viewer) return;

        const cam = viewer.scene.getActiveCamera();
        const dir = new THREE.Vector3();
        cam.getWorldDirection(dir);

        // Proyecci√≥n sobre plano XY
        dir.z = 0;
        dir.normalize();

        const angle = Math.atan2(dir.x, dir.y); // respecto al eje Y (norte)
        const grados = angle * (180 / Math.PI); // üëà conversi√≥n directa

        arrow.style.transform = `rotate(${-grados}deg)`; // flecha apunta al norte
      }

      // Verificar visibilidad cada 3 segundos
      setInterval(checkAndRestoreCloudVisibility, 3000);

      // Funci√≥n para optimizar la carga inicial
      function optimizeInitialLoading() {
        if (!cloudLoaded || !pointcloud) return;

        debug("Optimizando carga inicial de la nube...");

        // Secuencia de carga progresiva
        const progressiveLoad = (budget, delay) => {
          setTimeout(() => {
            viewer.setPointBudget(budget);
            debug(
              `Incrementando presupuesto de puntos a ${budget.toLocaleString()}`
            );
            viewer.scene.dispatchEvent({ type: "update" });
          }, delay);
        };

        // Comenzar con pocos puntos y aumentar progresivamente
        viewer.setPointBudget(MAX_PUNTOS_CARGA * 0.2); // 20% inicial

        progressiveLoad(MAX_PUNTOS_CARGA * 0.4, 1000); // 40% tras 1s
        progressiveLoad(MAX_PUNTOS_CARGA * 0.6, 2000); // 60% tras 2s
        progressiveLoad(MAX_PUNTOS_CARGA * 0.8, 3000); // 80% tras 3s
        progressiveLoad(MAX_PUNTOS_CARGA * 1.0, 4000); // 100% tras 4s

        // Ocultar pantalla de carga justo despu√©s de la carga total
        setTimeout(() => {
          const pantalla = document.getElementById("loading-screen");
          pantalla.style.opacity = 0;
          setTimeout(() => (pantalla.style.display = "none"), 500);
          debug(
            "Pantalla de carga ocultada tras completar la carga progresiva."
          );
        }, 4500);
      }

      // Inicializar el panel desplegable
      document.addEventListener("DOMContentLoaded", function () {
        // Configurar el toggle del panel desplegable
        const toggleBtn = document.getElementById("toggle-panel");
        const pointsPanel = document.getElementById("points-panel");

        // Estado inicial: expandido
        let isPanelCollapsed = true;
        document.getElementById("toggle-panel").textContent = "‚â´";

        toggleBtn.addEventListener("click", function () {
          const contenido = document.getElementById("points-panel-content");
          const hayCajas = contenido && contenido.children.length > 0;

          if (!hayCajas && isPanelCollapsed) {
            debug("‚õî Panel bloqueado porque no hay usuarios visibles.");
            return; // No se abre si est√° vac√≠o
          }

          isPanelCollapsed = !isPanelCollapsed;

          if (isPanelCollapsed) {
            pointsPanel.classList.add("panel-collapsed");
            toggleBtn.textContent = "‚â´";
          } else {
            pointsPanel.classList.remove("panel-collapsed");
            toggleBtn.textContent = "‚â™";
          }

          debug(
            `Panel de puntos ${isPanelCollapsed ? "contra√≠do" : "expandido"}`
          );
        });

        debug("Panel desplegable de puntos GPS inicializado");
      });

      // Llamar a la funci√≥n de optimizaci√≥n despu√©s de cargar la nube
      // A√±ade esta l√≠nea al final del bloque donde se carga la nube de puntos (l√≠nea ~465)
      setTimeout(optimizeInitialLoading, 1000);

      //----------------------------

      // Configurar los botones del panel de control lateral
      document.addEventListener("DOMContentLoaded", function () {
        setTimeout(() => {
          try {
            document
              .getElementById("btn-full-extent")
              .addEventListener("click", function () {
                if (camaraEnganchadaA !== null) {
                  debug(
                    `üîì C√°mara desenganchada de ${camaraEnganchadaA} (bot√≥n Full Extent)`
                  );
                  camaraEnganchadaA = null;

                  const cajas = document.querySelectorAll(
                    ".point-item.selected"
                  );
                  cajas.forEach((caja) => caja.classList.remove("selected"));
                  document
                    .querySelectorAll(".follow-status")
                    .forEach((elem) => (elem.style.display = "none"));
                }

                const pos = {
                  x: 520733.27100245113,
                  y: 1217765.8034400654,
                  z: 1380.2490794543892,
                };
                const foco = {
                  x: 522986.192278496,
                  y: 1217646.0842854953,
                  z: 30.206114982700683,
                };

                cameraMoving = false;
                moveCamera(pos.x, pos.y, pos.z, foco.x, foco.y, foco.z, false);
                debug("üåç C√°mara enviada a vista Full Extent personalizada");
              });

            document
              .getElementById("btn-move-5m")
              .addEventListener("click", function () {
                if (!cloudLoaded) {
                  debug("Nube no cargada. No se puede trazar trayectoria.");
                  return;
                }

                // Si ya hay l√≠neas creadas, alternar visibilidad
                if (window.trayectoriasLineas.size > 0) {
                  for (const [id, linea] of window.trayectoriasLineas) {
                    linea.visible = !linea.visible;
                  }
                  debug(
                    "Trayectorias visibles: " +
                      [...window.trayectoriasLineas.values()].filter(
                        (l) => l.visible
                      ).length
                  );
                  viewer.scene.dispatchEvent({ type: "update" });
                  return;
                }

                // Crear l√≠neas por cada usuario con trayectoria suficiente
                for (const [id, trayectoria] of window.trayectoriasPorUsuario) {
                  if (trayectoria.length < 2) continue;

                  const puntos = trayectoria
                    .map((p) => {
                      const coords = convertGPSToCloudCoords(
                        p.latitude,
                        p.longitude,
                        p.altitude
                      );
                      return coords
                        ? new THREE.Vector3(coords.x, coords.y, coords.z)
                        : null;
                    })
                    .filter((p) => p !== null);

                  if (puntos.length < 2) continue;

                  const geometry = new THREE.BufferGeometry().setFromPoints(
                    puntos
                  );
                  const color = new THREE.Color(
                    userLocations.get(id)?.color || 0xffffff
                  );
                  const material = new THREE.LineBasicMaterial({
                    color: color,
                  });

                  const linea = new THREE.Line(geometry, material);
                  linea.name = `Trayectoria_${id}`;
                  linea.visible = true; // üëà Activar aqu√≠
                  viewer.scene.scene.add(linea);

                  window.trayectoriasLineas.set(id, linea);
                }

                //

                if (window.trayectoriasLineas.size > 0) {
                  debug(
                    "Trayectorias dibujadas para: " +
                      [...window.trayectoriasLineas.keys()].join(", ")
                  );
                  viewer.scene.dispatchEvent({ type: "update" });
                } else {
                  alert("No se encontraron trayectorias v√°lidas.");
                }
              });

            document
              .getElementById("btn-home")
              .addEventListener("click", function () {
                if (camaraEnganchadaA !== null) {
                  debug(
                    `üîì C√°mara desenganchada de ${camaraEnganchadaA} (bot√≥n casa)`
                  );
                  camaraEnganchadaA = null;

                  const cajas = document.querySelectorAll(
                    ".point-item.selected"
                  );
                  cajas.forEach((caja) => caja.classList.remove("selected"));
                  document
                    .querySelectorAll(".follow-status")
                    .forEach((elem) => (elem.style.display = "none"));
                }

                const pos = {
                  x: 524771.285943634,
                  y: 1215882.4076521,
                  z: 69.51156807146481,
                };
                const foco = { x: 524823.59, y: 1215810.79, z: 31.98 };

                cameraMoving = false;
                moveCamera(pos.x, pos.y, pos.z, foco.x, foco.y, foco.z, false); // usarOffset = false
                debug(
                  "üè† C√°mara enviada al punto de origen con transici√≥n suave calibrada"
                );
              });

            //
            // Aseg√∫rate de que los iconos est√©n visibles y sean clicables
            const buttons = document.querySelectorAll("#left-toolbar button");
            buttons.forEach((button) => {
              // Forzar visibilidad y estilos correctos
              const icon = button.querySelector("i");
              if (icon) {
                icon.style.display = "block";
                icon.style.visibility = "visible";
                icon.style.opacity = "1";
              }

              // A√±adir clases adicionales para asegurar funcionamiento
              button.style.cursor = "pointer";
              button.style.display = "flex";
              button.style.justifyContent = "center";
              button.style.alignItems = "center";

              debug(`Bot√≥n configurado: ${button.id}`);
            });

            debug("Panel de control lateral configurado correctamente");
          } catch (e) {
            debug(`Error al configurar panel de control lateral: ${e.message}`);
          }
        }, 3000); // Aumentar a 3 segundos para asegurar que todo est√© cargado
      });

      // A√±adir al final de la configuraci√≥n de los botones del panel de control lateral (l√≠nea ~755)
      // Forzar carga espec√≠fica del icono Full Extent
      const fullExtentIcon = document.querySelector(".potree_full_extent_icon");
      if (fullExtentIcon) {
        fullExtentIcon.style.backgroundImage =
          "url('./libs/potree/resources/icons/fit.svg')";
        debug("Icono Full Extent forzado");
      }

      //-------------------------------------
      // Funci√≥n para asegurar que los iconos se cargan correctamente
      function ensureIconsLoaded() {
        const toolbarButtons = document.querySelectorAll(
          "#left-toolbar button i"
        );
        toolbarButtons.forEach((icon) => {
          // Forzar recarga del estilo del icono
          const computedStyle = window.getComputedStyle(icon);
          if (
            computedStyle.backgroundImage === "none" ||
            computedStyle.width === "0px"
          ) {
            // Recargar el icono aplicando nuevamente la clase
            const className = Array.from(icon.classList).find((cls) =>
              cls.includes("potree_")
            );
            if (className) {
              icon.classList.remove(className);
              setTimeout(() => icon.classList.add(className), 10);
            }
          }
        });
      }

      // Llamar a la funci√≥n despu√©s de cargar la p√°gina y nuevamente despu√©s de un segundo
      document.addEventListener("DOMContentLoaded", function () {
        setTimeout(ensureIconsLoaded, 500);
        setTimeout(ensureIconsLoaded, 1500);
      });
    </script>

    <div id="loading-screen">
      <div class="loading-box">
        <h1 class="logo-title">GPSRENDER</h1>
        <div class="spinner"></div>
        <p>Cargando escena 3D...</p>
      </div>
    </div>
  </body>
</html>
