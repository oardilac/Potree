<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="description" content="Sistema GPS con Nube de Puntos Potree" />
    <meta name="author" content="" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>Sistema GPS Potree</title>

    <link rel="stylesheet" type="text/css" href="./libs/potree/potree.css" />
    <link
      rel="stylesheet"
      type="text/css"
      href="./libs/jquery-ui/jquery-ui.min.css"
    />
    <link rel="stylesheet" type="text/css" href="./libs/openlayers3/ol.css" />
    <link rel="stylesheet" type="text/" href="./libs/spectrum/spectrum.css" />
    <link
      rel="stylesheet"
      type="text/css"
      href="./libs/jstree/themes/mixed/style.css"
    />

    <script src="https://sdk.amazonaws.com/js/aws-sdk-2.1480.0.min.js"></script>

    <style>
      .coordinate-display {
        margin-top: 10px;
        padding: 5px;
        background: rgba(0, 0, 0, 0.1);
        border-radius: 3px;
      }

      .point-item.selected {
        background-color: rgba(
          255,
          255,
          0,
          0.2
        ); /* Amarillo claro translúcido */
        border-left: 4px solid gold;
        border-radius: 6px;
      }
      #debug-panel {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        padding: 10px;
        border-radius: 5px;
        z-index: 1000;
        width: 400px;
        max-height: 200px;
        overflow-y: auto;
        font-family: monospace;
        font-size: 12px;
      }

      .marker-label {
        color: white;
        background-color: rgba(0, 0, 0, 0.6);
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 12px;
        font-weight: bold;
        white-space: nowrap;
        pointer-events: none;
      }

      #simple-controls {
        position: absolute;
        bottom: 30px;
        right: 10px;
        background: rgba(255, 255, 255, 0.8);
        padding: 10px;
        border-radius: 5px;
        z-index: 1000;
        display: flex;
        flex-direction: column;
      }

      #simple-controls button {
        margin: 5px;
        padding: 8px;
        background-color: #4caf50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        width: 180px;
      }

      #simple-controls button:hover {
        background-color: #45a049;
      }

      #left-toolbar {
        position: absolute;
        right: 10px;
        left: auto;
        top: 50%;
        transform: translateY(-50%);
        background: rgba(255, 255, 255, 0.8);
        padding: 10px;
        border-radius: 5px;
        z-index: 1000;
        display: flex;
        flex-direction: column;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      }

      #left-toolbar button {
        margin: 5px 0;
        padding: 8px;
        background-color: #4caf50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        width: 40px;
        height: 40px;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      #left-toolbar button:hover {
        background-color: #45a049;
      }

      #left-toolbar button i {
        font-size: 20px;
      }

      /*********************************************** Iconos de Potree */
      /* Mejorar la carga de iconos con rutas absolutas */
      .potree_full_extent_icon::before {
        content: "";
        display: inline-block;
        width: 24px;
        height: 24px;
        background-image: url("./libs/potree/resources/icons/helicopter_controls.svg");
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
      }

      .potree_move_icon::before {
        content: "";
        display: inline-block;
        width: 24px;
        height: 24px;
        background-image: url("./libs/potree/resources/icons/arrow_right.svg");
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
      }
      /*********************************************** Iconos de Potree */

      /* Paso 5: Añade estilos para mejorar la visualización de los botones */
      #left-toolbar button {
        position: relative;
        overflow: visible;
      }

      #left-toolbar button i {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 24px;
        height: 24px;
      }

      /* Eliminar completamente el panel de Potree */
      #potree_sidebar_container,
      .potree_container .sidebar,
      .potree_menu_toggle,
      .potree_logo,
      .potree_menu_buttons,
      .potree_tool_icon,
      #potree_sidebar_container * {
        display: none !important;
        width: 0 !important;
        height: 0 !important;
        visibility: hidden !important;
        opacity: 0 !important;
        pointer-events: none !important;
        overflow: hidden !important;
        position: absolute !important;
        left: -9999px !important;
      }

      /* Asegurarse que no queden rastros del panel */
      .potree_container {
        position: absolute;
        width: 100%;
        height: 100%;
        left: 0px !important;
        right: 0px !important;
        pointer-events: auto;
      }

      #potree_render_area {
        left: 0px !important;
        right: 0px !important;
        width: 100% !important;
        position: absolute;
      }

      /* Estilos para el nuevo panel desplegable */
      #points-panel {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 5px;
        z-index: 1001;
        width: 320px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        transition: transform 0.3s ease;
        max-height: 80vh;
        display: flex;
        flex-direction: column;
      }

      #points-panel-header {
        padding: 10px;
        background: #4caf50;
        color: white;
        border-radius: 5px 5px 0 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
      }

      #points-panel-content {
        padding: 0;
        overflow-y: auto;
        max-height: calc(80vh - 40px);
      }

      .point-item {
        padding: 10px;
        border-bottom: 1px solid #ddd;
        display: flex;
        align-items: center;
      }

      .point-item:last-child {
        border-bottom: none;
      }

      .point-icon {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background-color: #ff0000;
        margin-right: 10px;
        flex-shrink: 0;
      }

      .point-details {
        flex-grow: 1;
      }

      .point-title {
        font-weight: bold;
        margin-bottom: 5px;
      }

      .point-coords {
        font-size: 12px;
        color: #666;
        font-family: monospace;
      }

      .panel-collapsed {
        transform: translateX(-290px);
      }

      .toggle-btn {
        background: none;
        border: none;
        cursor: pointer;
        font-size: 18px;
        color: white;
        padding: 0;
      }

      .point-item {
        cursor: pointer;
        transition: background-color 0.3s, box-shadow 0.3s;
      }

      .point-item:hover {
        background-color: rgba(76, 175, 80, 0.1); /* Verde claro translúcido */
        box-shadow: 0 0 8px rgba(76, 175, 80, 0.3); /* Sombra verde tenue */
        border-radius: 5px;
      }
    </style>
  </head>

  <body>
    <script src="./libs/jquery/jquery-3.1.1.min.js"></script>
    <script src="./libs/spectrum/spectrum.js"></script>
    <script src="./libs/jquery-ui/jquery-ui.min.js"></script>
    <script src="./libs/three.js/build/three.min.js"></script>
    <script src="./libs/three.js/extra/lines.js"></script>
    <script src="./libs/other/BinaryHeap.js"></script>
    <script src="./libs/tween/tween.min.js"></script>
    <script src="./libs/d3/d3.js"></script>
    <script src="./libs/proj4/proj4.js"></script>
    <script src="./libs/openlayers3/ol.js"></script>
    <script src="./libs/i18next/i18next.js"></script>
    <script src="./libs/jstree/jstree.js"></script>
    <script src="./libs/potree/potree.js"></script>
    <script src="./libs/plasio/js/laslaz.js"></script>

    <div
      class="potree_container"
      style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px"
    >
      <div
        id="potree_render_area"
        style="
          background-image: url('./libs/potree/resources/images/background.jpg');
        "
      ></div>
      <div
        id="potree_sidebar_container"
        style="
          display: none !important;
          width: 0;
          height: 0;
          overflow: hidden;
          position: absolute;
        "
      ></div>

      <div id="left-toolbar">
        <button id="btn-full-extent" title="Full Extent">
          <i class="potree_full_extent_icon"></i>
        </button>
        <button id="btn-move-5m" title="Mover 5m al Este">
          <i class="potree_move_icon"></i>
        </button>
      </div>
    </div>

    <!-- Eliminar completamente el panel de depuración en lugar de ocultarlo -->
    <div
      id="debug-panel"
      style="
        display: none !important;
        width: 0;
        height: 0;
        overflow: hidden;
        position: absolute;
        visibility: hidden;
        opacity: 0;
      "
    >
      <!-- El contenido se mantendrá invisible y completamente eliminado del flujo del documento -->
    </div>

    <!-- Nuevo panel desplegable para puntos -->
    <div id="points-panel">
      <div id="points-panel-header">
        <span>Puntos GPS</span>
        <button class="toggle-btn" id="toggle-panel">≪</button>
      </div>
      <div id="points-panel-content">
        <!-- Los puntos se agregarán dinámicamente aquí -->
      </div>
    </div>

    <script>
      // Función para mostrar mensajes de depuración
      function debug(message) {
        // Solo envía a la consola, no al panel visual
        console.log(`[DEBUG] ${message}`);
      }

      debug("Iniciando aplicación...");

      // Inicializar el visor Potree
      window.viewer = new Potree.Viewer(
        document.getElementById("potree_render_area")
      );

      // Configuración del visor
      viewer.setEDLEnabled(true);
      viewer.setFOV(60);
      viewer.setPointBudget(2_500_000);
      viewer.setBackground("gradient");
      viewer.loadSettingsFromURL();

      debug(
        "Visor Potree inicializado correctamente con densidad máxima fija de 2,500,000 puntos"
      );

      // Variables globales
      let gpsMarker = null;
      let camaraEnganchadaA = null; // ID del usuario actualmente enganchado

      const userLocations = new Map(); // key: id, value: { lat, lon, alt, color }

      // Mapa de ID a marcador (para actualización futura)
      const userMarkers = {};
      const estadoUsuarios = new Map(); // id → { ultimoTimestamp, ciclosSinCambio }
      const MAX_CICLOS_SIN_CAMBIO = 3; // puedes ajustar este valor

      let annotations = null;
      let pointcloud = null;
      let labelDiv = null;
      let cloudLoaded = false;
      let referenceMarker = null;
      let cameraMoving = false;
      let gpsBlinkInterval = null;
      let gpsDB = null;
      const MAX_PUNTOS = 600;
      let ultimaPosicionCamara = new Map(); // id → { x, y, z }
      window.trayectoriasPorUsuario = new Map(); // id → lista de posiciones por usuario
      window.trayectoriasLineas = new Map(); // id → objeto THREE.Line por usuario

      //-------------------------------------------------------------

      // Función para convertir coordenadas en formato DMS (grados, minutos, segundos) a decimal
      function dmsToDecimal(degrees, minutes, seconds, direction) {
        let decimal = degrees + minutes / 60 + seconds / 3600;
        // Si la dirección es Sur (S) o Oeste (W/O), el valor debe ser negativo
        if (direction === "S" || direction === "W" || direction === "O") {
          decimal = -decimal;
        }
        return decimal;
      }

      //--------------------------------------------------------------

      // Función para convertir coordenadas decimales a formato DMS (grados, minutos, segundos)
      function decimalToDMS(decimal, isLatitude) {
        // Asegurar que el valor es positivo para el cálculo
        const absDecimal = Math.abs(decimal);

        // Calcular grados (parte entera)
        const degrees = Math.floor(absDecimal);

        // Calcular minutos (parte decimal * 60, y luego tomar la parte entera)
        const minutesDecimal = (absDecimal - degrees) * 60;
        const minutes = Math.floor(minutesDecimal);

        // Calcular segundos (parte decimal de los minutos * 60)
        const seconds = ((minutesDecimal - minutes) * 60).toFixed(2);

        // Determinar la dirección (N/S para latitud, E/O para longitud)
        let direction;
        if (isLatitude) {
          direction = decimal >= 0 ? "N" : "S";
        } else {
          direction = decimal >= 0 ? "E" : "O";
        }

        // Formatear el resultado
        return `${degrees}° ${minutes}' ${seconds}" ${direction}`;
      }

      window.awsConfig = {
        region: "us-east-1",
        accessKeyId: "AKIAZCRUSKBBWDBPX4PN",
        secretAccessKey: "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",
      };

      // Punto de referencia conocido para la conversión (aleta de tiburón)
      const referencePoint = {
        // Coordenadas GPS en formato crudo
        gpsRaw: {
          lat: { degrees: 10, minutes: 59, seconds: 54.22, direction: "N" },
          lon: { degrees: 74, minutes: 46, seconds: 21.87, direction: "O" },
          alt: 3, // 3 metros
        },
        // Coordenadas GPS (latitud, longitud, altitud) en decimal
        gps: {
          lat: null, // Se calculará a continuación
          lon: null, // Se calculará a continuación
          alt: 3, // 3 metros
        },
        // Coordenadas en la nube Potree
        cloud: {
          x: 524823.59,
          y: 1215810.79,
          z: 31.98,
        },
      };

      // Convertir coordenadas crudas a decimal
      referencePoint.gps.lat = dmsToDecimal(
        referencePoint.gpsRaw.lat.degrees,
        referencePoint.gpsRaw.lat.minutes,
        referencePoint.gpsRaw.lat.seconds,
        referencePoint.gpsRaw.lat.direction
      );

      referencePoint.gps.lon = dmsToDecimal(
        referencePoint.gpsRaw.lon.degrees,
        referencePoint.gpsRaw.lon.minutes,
        referencePoint.gpsRaw.lon.seconds,
        referencePoint.gpsRaw.lon.direction
      );

      // Agregar mensaje de depuración para confirmar la conversión
      debug(`Punto de referencia (convertido): 
            GPS: (${referencePoint.gps.lat}, ${referencePoint.gps.lon}, ${referencePoint.gps.alt})
            Nube: (${referencePoint.cloud.x}, ${referencePoint.cloud.y}, ${referencePoint.cloud.z})`);

      //----------------------------------------------------------------------

      debug(`Punto de referencia configurado: 
            GPS: (${referencePoint.gps.lat}, ${referencePoint.gps.lon}, ${referencePoint.gps.alt})
            Nube: (${referencePoint.cloud.x}, ${referencePoint.cloud.y}, ${referencePoint.cloud.z})`);

      //----------------------------------------------------------------------------

      // Función para convertir coordenadas GPS a coordenadas de la nube
      function convertGPSToCloudCoords(lat, lon, alt) {
        debug(
          `Convirtiendo coordenadas GPS (${lat}, ${lon}, ${alt}) a coordenadas de nube...`
        );

        try {
          // Calculamos la diferencia en grados
          const dLat = lat - referencePoint.gps.lat;
          const dLon = lon - referencePoint.gps.lon;
          const dAlt = alt - referencePoint.gps.alt;

          // Conversión aproximada: 1 grado de latitud ≈ 111.32 km = 111320 metros
          // En el Ecuador, 1 grado de longitud ≈ 111.32 km, pero varía con la latitud
          // Factor de corrección para longitud: cos(latitud en radianes)
          const lonCorrectionFactor = Math.cos(
            (referencePoint.gps.lat * Math.PI) / 180
          );

          // Convertimos diferencias en grados a metros (aproximado)
          const dY = dLat * 111320; // Norte-Sur
          const dX = dLon * 111320 * lonCorrectionFactor; // Este-Oeste

          // Aplicamos la diferencia a las coordenadas de la nube
          const cloudX = referencePoint.cloud.x + dX;
          const cloudY = referencePoint.cloud.y + dY;
          const cloudZ = referencePoint.cloud.z + dAlt;

          debug(
            `Coordenadas convertidas: (${cloudX.toFixed(2)}, ${cloudY.toFixed(
              2
            )}, ${cloudZ.toFixed(2)})`
          );

          return {
            x: cloudX,
            y: cloudY,
            z: cloudZ,
          };
        } catch (error) {
          debug(`ERROR en la conversión de coordenadas: ${error.message}`);
          console.error("Error en la conversión de coordenadas:", error);
          return null;
        }
      }

      //-------------------------------------------------------------------------------

      // Función para crear/actualizar el marcador en la nube
      function updateMarker(x, y, z, lat = null, lon = null, alt = null) {
        debug(
          `Intentando crear marcador en (${x.toFixed(2)}, ${y.toFixed(
            2
          )}, ${z.toFixed(2)})...`
        );

        // Si no se proporcionan coordenadas GPS, intentar calcularlas inversamente (aproximación)
        if (lat === null || lon === null || alt === null) {
          // Este es un cálculo inverso aproximado
          const dX = x - referencePoint.cloud.x;
          const dY = y - referencePoint.cloud.y;
          const dZ = z - referencePoint.cloud.z;

          // Factor de corrección para longitud: cos(latitud en radianes)
          const lonCorrectionFactor = Math.cos(
            (referencePoint.gps.lat * Math.PI) / 180
          );

          // Convertir diferencias en metros a grados (aproximado)
          const dLat = dY / 111320;
          const dLon = dX / (111320 * lonCorrectionFactor);

          lat = referencePoint.gps.lat + dLat;
          lon = referencePoint.gps.lon + dLon;
          alt = referencePoint.gps.alt + dZ;
        }

        // Resto del código de la función updateMarker...

        try {
          // Eliminar marcador anterior si existe
          if (gpsMarker) {
            viewer.scene.scene.remove(gpsMarker);
            debug("Marcador anterior eliminado");
          }

          // Iniciar efecto de parpadeo
          if (gpsBlinkInterval) {
            clearInterval(gpsBlinkInterval);
          }

          let visible = true;
          gpsBlinkInterval = setInterval(() => {
            if (gpsMarker && gpsMarker.material) {
              gpsMarker.material.opacity = visible ? 0.0 : 0.8;
              gpsMarker.material.needsUpdate = true;
              visible = !visible;
            }
          }, 500); // 500ms = 0.5 segundos

          // Eliminar etiqueta anterior si existe
          if (labelDiv) {
            const container = document.getElementById("potree_render_area");
            container.removeChild(labelDiv);
            labelDiv = null;
            debug("Etiqueta anterior eliminada");
          }

          // Crear nuevo marcador (esfera roja)
          const sphereGeometry = new THREE.SphereGeometry(2, 32, 32);
          const sphereMaterial = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            opacity: 0.8,
            transparent: true,
          });
          gpsMarker = new THREE.Mesh(sphereGeometry, sphereMaterial);
          gpsMarker.position.set(x, y, z);
          viewer.scene.scene.add(gpsMarker);
          debug("Marcador (esfera) creado y añadido a la escena");

          // Crear etiqueta
          labelDiv = document.createElement("div");
          labelDiv.className = "marker-label";
          labelDiv.style.position = "absolute";
          labelDiv.style.padding = "10px";
          labelDiv.style.background = "rgba(0, 0, 0, 0.7)";
          labelDiv.style.color = "white";
          labelDiv.style.borderRadius = "5px";
          labelDiv.style.pointerEvents = "none";
          labelDiv.style.zIndex = "1000";
          labelDiv.innerHTML = `
                    <span style="font-weight: bold;">Posición GPS</span><br>
                    X: ${x.toFixed(2)}, Y: ${y.toFixed(2)}, Z: ${z.toFixed(2)}
                `;

          // Añadir etiqueta al contenedor
          const container = document.getElementById("potree_render_area");
          container.appendChild(labelDiv);

          // Actualizar posición de la etiqueta en cada frame
          function updateLabelPosition() {
            if (!gpsMarker) return;

            // Verificar si la cámara y el marcador existen
            const camera = viewer.scene.getActiveCamera();
            if (!camera) return;

            const screenPos = gpsMarker.position.clone().project(camera);

            // Verificar si el punto está delante de la cámara (z < 1)
            if (screenPos.z < 1) {
              // Convertir a coordenadas de pantalla
              const x = ((screenPos.x + 1) * container.clientWidth) / 2;
              const y = ((-screenPos.y + 1) * container.clientHeight) / 2;

              // Actualizar posición de la etiqueta
              labelDiv.style.left = `${x}px`;
              labelDiv.style.top = `${y - 50}px`; // Desplazar un poco arriba
              labelDiv.style.display = "block";
            } else {
              // Ocultar la etiqueta si está detrás de la cámara
              labelDiv.style.display = "none";
            }

            requestAnimationFrame(updateLabelPosition);
          }

          // Iniciar la actualización
          updateLabelPosition();

          // Mostrar las coordenadas convertidas en la interfaz
          document.getElementById("cloud-coords").textContent = `X: ${x.toFixed(
            2
          )}, Y: ${y.toFixed(2)}, Z: ${z.toFixed(2)}`;

          // Mover la cámara de forma suave
          moveCamera(x, y, z);

          debug("Coordenadas convertidas mostradas en la interfaz");
        } catch (error) {
          debug(`ERROR al crear marcador: ${error.message}`);
          console.error("Error al crear marcador:", error);
        }

        // Actualizar el panel desplegable con las coordenadas del marcador
        updatePointPanel(x, y, z, lat, lon, alt);
      }

      //--------------------------------------------------------------------------------

      function createUserMarker(x, y, z, user) {
        const geometry = new THREE.SphereGeometry(1.0, 16, 16); // Tamaño corregido
        const material = new THREE.MeshBasicMaterial({ color: user.color });
        const marker = new THREE.Mesh(geometry, material);

        // 💡 Efecto de parpadeo
        marker.onBeforeRender = function (
          renderer,
          scene,
          camera,
          geometry,
          material,
          group
        ) {
          const t = performance.now() * 0.005;
          const scale = 1 + 0.25 * Math.sin(t);
          marker.scale.set(scale, scale, scale);
        };

        marker.position.set(x, y, z);
        viewer.scene.scene.add(marker);

        function headingToCompass(deg) {
          if (deg === undefined || deg === null || deg < 0) return "—";
          const sectores = [
            "Norte", // 337.5° – 22.5°
            "Noreste", // 22.5° – 67.5°
            "Este", // 67.5° – 112.5°
            "Sureste", // 112.5° – 157.5°
            "Sur", // 157.5° – 202.5°
            "Suroeste", // 202.5° – 247.5°
            "Oeste", // 247.5° – 292.5°
            "Noroeste", // 292.5° – 337.5°
          ];
          // índice 0-7 según el ángulo
          const idx = Math.floor(((deg + 22.5) % 360) / 45);
          return sectores[idx];
        }

        const headingTxt = headingToCompass(user.custom?.heading);
        const speedTxt =
          user.custom?.speed !== undefined
            ? Number(user.custom.speed).toFixed(3) // 3 decimales
            : "—";

        const div = document.createElement("div");
        div.className = "point-item";
        div.id = `user-panel-${user.id}`;
        div.innerHTML = `
                <div class="point-icon" style="background-color: ${
                  user.color
                };"></div>
                <div class="point-details">
                    <div class="point-title">Usuario ${user.id}</div>
                    <div class="point-coords">
                        Lat: ${decimalToDMS(user.lat, true)}<br>
                        Lon: ${decimalToDMS(user.lon, false)}<br>
                        Alt: ${user.alt.toFixed(2)} m
                        Vel.: ${speedTxt} m/s<br>
                        Heading: ${headingTxt}<br>
                    </div>
                    <div class="follow-status" style="font-size: 12px; color: green; font-weight: bold; display: none;">📍 Siguiendo</div>
                    <div class="connect-status" style="font-size: 12px; font-weight: bold; color: green;">📶 Conectado</div>
                </div>
            `;

        // ✅ Enganche bloqueado si está desconectado
        div.addEventListener("click", () => {
          const estadoActual = estadoUsuarios.get(user.id);
          const desconectado =
            estadoActual?.ciclosSinCambio >= MAX_CICLOS_SIN_CAMBIO;

          if (desconectado) {
            debug(
              `🚫 Usuario ${user.id} está desconectado. Enganche desde createUserMarker() bloqueado.`
            );
            return;
          }

          const yaEnganchado = camaraEnganchadaA === user.id;

          if (camaraEnganchadaA !== null) {
            const anterior = document.getElementById(
              `user-panel-${camaraEnganchadaA}`
            );
            if (anterior) {
              anterior.classList.remove("selected");
              const textoAnterior = anterior.querySelector(".follow-status");
              if (textoAnterior) textoAnterior.style.display = "none";
            }
          }

          if (yaEnganchado) {
            camaraEnganchadaA = null;
            debug(`🔓 Cámara desenganchada`);
          } else {
            camaraEnganchadaA = user.id;
            div.classList.add("selected");
            const texto = div.querySelector(".follow-status");
            if (texto) texto.style.display = "block";

            if (!cameraMoving) {
              moveCamera(
                marker.position.x,
                marker.position.y,
                marker.position.z
              );
              ultimaPosicionCamara.set(user.id, {
                x: marker.position.x,
                y: marker.position.y,
                z: marker.position.z,
              });
            }

            debug(`📌 Cámara enganchada a Usuario ${user.id}`);
          }
        });

        const panel = document.getElementById("points-panel-content");
        panel.appendChild(div);

        return marker;
      }

      //---------------------------------------------------------------------------------

      function actualizarUsuariosDesdeAWS(positions) {
        const idsRecibidos = new Set();

        positions.forEach((datos) => {
          const id = datos.id;
          const timestampActual = datos.timestamp || Date.now() / 1000;

          // Registrar o actualizar estado
          if (!estadoUsuarios.has(id)) {
            estadoUsuarios.set(id, {
              ultimoTimestamp: timestampActual,
              ciclosSinCambio: 0,
            });
          } else {
            const estado = estadoUsuarios.get(id);
            if (estado.ultimoTimestamp === timestampActual) {
              estado.ciclosSinCambio++;
            } else {
              estado.ultimoTimestamp = timestampActual;
              estado.ciclosSinCambio = 0;
            }
          }

          const estado = estadoUsuarios.get(id);
          const desconectado = estado.ciclosSinCambio >= MAX_CICLOS_SIN_CAMBIO;

          if (desconectado) {
            debug(
              `🟥 Usuario ${id} se considera desconectado. Eliminando marcador...`
            );

            if (camaraEnganchadaA === id) {
              camaraEnganchadaA = null;
              debug(`🔓 Cámara desenganchada de ${id} (usuario desconectado)`);

              const panelCaja = document.getElementById(`user-panel-${id}`);
              if (panelCaja) {
                const seguimiento = panelCaja.querySelector(".follow-status");
                if (seguimiento) seguimiento.style.display = "none";
              }
            }

            if (userMarkers[id]) {
              viewer.scene.scene.remove(userMarkers[id]);
              delete userMarkers[id];
            }

            const panel = document.getElementById(`user-panel-${id}`);
            if (panel) {
              const estadoTexto = panel.querySelector(".connect-status");
              if (estadoTexto) {
                estadoTexto.textContent = "📶 Desconectado";
                estadoTexto.style.color = "gray";
              }
            }

            const linea = window.trayectoriasLineas.get(id);
            if (linea) linea.visible = false;

            return;
          }

          // Usuario activo
          let user = userLocations.get(id);
          if (!user) {
            const colores = [
              "#ff0000",
              "#00ff00",
              "#0000ff",
              "#ffff00",
              "#00ffff",
              "#ff00ff",
            ];
            const color = colores[userLocations.size % colores.length];
            user = {
              id: id,
              lat: datos.lat,
              lon: datos.lon,
              alt: datos.alt,
              color: color,
              custom: datos.custom,
            };
            userLocations.set(id, user);
          } else {
            user.lat = datos.lat;
            user.lon = datos.lon;
            user.alt = datos.alt;
          }

          idsRecibidos.add(id);

          const cloud = convertGPSToCloudCoords(user.lat, user.lon, user.alt);
          if (!cloud || isNaN(cloud.x) || isNaN(cloud.y) || isNaN(cloud.z)) {
            console.warn(`Coordenadas inválidas para usuario ${id}, se omite.`);
            return;
          }

          if (!window.trayectoriasPorUsuario.has(id)) {
            window.trayectoriasPorUsuario.set(id, []);
          }
          const trayectoria = window.trayectoriasPorUsuario.get(id);
          if (
            trayectoria.length === 0 ||
            trayectoria[trayectoria.length - 1].x !== cloud.x ||
            trayectoria[trayectoria.length - 1].y !== cloud.y ||
            trayectoria[trayectoria.length - 1].z !== cloud.z
          ) {
            trayectoria.push({
              x: cloud.x,
              y: cloud.y,
              z: cloud.z,
              ts: datos.timestamp,
            });
          }
          if (trayectoria.length > MAX_PUNTOS) {
            trayectoria.splice(0, trayectoria.length - MAX_PUNTOS);
          }
          trayectoria.push({
            x: cloud.x,
            y: cloud.y,
            z: cloud.z,
            ts: datos.timestamp,
          });

          if (!userMarkers[id]) {
            userMarkers[id] = createUserMarker(cloud.x, cloud.y, cloud.z, user);
          } else {
            userMarkers[id].position.set(cloud.x, cloud.y, cloud.z);
          }

          // 🔒 Solo mover cámara si está enganchada y usuario está conectado
          const estaConectado = estado.ciclosSinCambio < MAX_CICLOS_SIN_CAMBIO;

          if (camaraEnganchadaA === id && estaConectado && !cameraMoving) {
            const ultima = ultimaPosicionCamara.get(id);
            const nueva = { x: cloud.x, y: cloud.y, z: cloud.z };
            const delta = ultima
              ? Math.abs(ultima.x - nueva.x) +
                Math.abs(ultima.y - nueva.y) +
                Math.abs(ultima.z - nueva.z)
              : Infinity;

            if (delta > 0.1) {
              moveCamera(nueva.x, nueva.y, nueva.z);
              ultimaPosicionCamara.set(id, nueva);
              debug(`📡 Cámara actualizada al moverse el usuario ${id}`);
            } else {
              debug(`🛑 Usuario ${id} no se ha movido, cámara permanece`);
            }
          }

          if (trayectoria.length < 2) return;

          const ultima = trayectoria[trayectoria.length - 1];
          const penultima = trayectoria[trayectoria.length - 2];
          const mismaPosicion =
            ultima.x === penultima.x &&
            ultima.y === penultima.y &&
            ultima.z === penultima.z;
          if (mismaPosicion) return;

          const puntos = trayectoria.map(
            (p) => new THREE.Vector3(p.x, p.y, p.z + 2)
          );
          // Crear una curva suave con los puntos
          const curva = new THREE.CatmullRomCurve3(
            puntos,
            false,
            "centripetal",
            0.5
          );
          const segments = Math.max(4, puntos.length * 3);

          // Crear un tubo alrededor de la curva (grosor = 0.2)
          const geometry = new THREE.TubeGeometry(
            curva,
            segments,
            0.2,
            8,
            false
          );
          const material = new THREE.MeshBasicMaterial({
            color: user.color,
            transparent: true,
            opacity: 1.0,
          });

          //---------------------------------------------------
          let linea = window.trayectoriasLineas.get(id);
          let visibleAntes = false;

          if (linea) {
            visibleAntes = linea.visible; // ✔ recordar visibilidad anterior
            viewer.scene.scene.remove(linea);
            linea.geometry.dispose();
            linea.material.dispose();
          }

          linea = new THREE.Mesh(geometry, material);
          linea.visible = visibleAntes; // ✔ restaurar visibilidad anterior
          viewer.scene.scene.add(linea);
          window.trayectoriasLineas.set(id, linea);

          //-------------------------------------------------------

          // Actualizar panel lateral
          const oldPanel = document.getElementById(`user-panel-${id}`);
          if (oldPanel) oldPanel.remove();

          function headingToCompass(deg) {
            if (deg === undefined || deg === null || deg < 0) return "—";
            const sectores = [
              "Norte", // 337.5° – 22.5°
              "Noreste", // 22.5° – 67.5°
              "Este", // 67.5° – 112.5°
              "Sureste", // 112.5° – 157.5°
              "Sur", // 157.5° – 202.5°
              "Suroeste", // 202.5° – 247.5°
              "Oeste", // 247.5° – 292.5°
              "Noroeste", // 292.5° – 337.5°
            ];
            // índice 0-7 según el ángulo
            const idx = Math.floor(((deg + 22.5) % 360) / 45);
            return sectores[idx];
          }

          const headingTxt = headingToCompass(user.custom?.heading);
          const speedTxt =
            user.custom?.speed !== undefined
              ? Number(user.custom.speed).toFixed(3) // 3 decimales
              : "—";

          const panelContenedor = document.getElementById(
            "points-panel-content"
          );
          const div = document.createElement("div");
          div.className = "point-item";
          div.id = `user-panel-${id}`;
          div.innerHTML = `
                    <div class="point-icon" style="background-color: ${
                      user.color
                    };"></div>
                    <div class="point-details">
                        <div class="point-title">Usuario ${user.id}</div>
                        <div class="point-coords">
                            Lat: ${decimalToDMS(user.lat, true)}<br>
                            Lon: ${decimalToDMS(user.lon, false)}<br>
                            Alt: ${user.alt.toFixed(2)} m<br>
                            Vel.: ${speedTxt} m/s<br>
                            Heading: ${headingTxt}<br>
                            <small>Nube: X=${cloud.x.toFixed(
                              2
                            )}, Y=${cloud.y.toFixed(2)}, Z=${cloud.z.toFixed(
            2
          )}</small>
                        </div>
                        <div class="follow-status" style="font-size: 12px; color: green; font-weight: bold; display: none;">📍 Siguiendo</div>
                        <div class="connect-status" style="font-size: 12px; font-weight: bold; color: green;">📶 Conectado</div>
                    </div>
                `;

          // ✅ Protección en tiempo real al hacer click en la tarjeta
          div.addEventListener("click", () => {
            const estadoAhora = estadoUsuarios.get(id);
            const estaDesconectado =
              estadoAhora?.ciclosSinCambio >= MAX_CICLOS_SIN_CAMBIO;

            if (estaDesconectado) {
              debug(`🚫 Usuario ${id} está desconectado. Enganche bloqueado.`);
              return;
            }

            const yaEnganchado = camaraEnganchadaA === id;

            if (camaraEnganchadaA !== null) {
              const anterior = document.getElementById(
                `user-panel-${camaraEnganchadaA}`
              );
              if (anterior) {
                anterior.classList.remove("selected");
                const textoAnterior = anterior.querySelector(".follow-status");
                if (textoAnterior) textoAnterior.style.display = "none";
              }
            }

            if (yaEnganchado) {
              camaraEnganchadaA = null;
              debug(`🔓 Cámara desenganchada`);
            } else {
              camaraEnganchadaA = id;
              div.classList.add("selected");
              const texto = div.querySelector(".follow-status");
              if (texto) texto.style.display = "block";

              const marcador = userMarkers[id];
              if (!cameraMoving && marcador) {
                moveCamera(
                  marcador.position.x,
                  marcador.position.y,
                  marcador.position.z
                );
                ultimaPosicionCamara.set(id, {
                  x: marcador.position.x,
                  y: marcador.position.y,
                  z: marcador.position.z,
                });
              }

              debug(`📌 Cámara enganchada a Usuario ${id}`);
            }
          });

          if (camaraEnganchadaA === id) {
            div.classList.add("selected");
            const texto = div.querySelector(".follow-status");
            if (texto) texto.style.display = "block";
          }

          panelContenedor.appendChild(div);
        });
      }

      //----------------------------------------------------------------------------------

      const VENTANA_TIEMPO_SEGUNDOS = 120; // 2 minutos de ventana móvil

      async function cargarDesdeAWS() {
        if (!gpsDB) return;

        try {
          const bruto = await gpsDB.getRecentPositions(1500); // ya ASC
          if (bruto.length === 0) return;

          /* Agrupar por id */
          const porId = new Map();
          bruto.forEach((p) => {
            if (!porId.has(p.id)) porId.set(p.id, []);
            porId.get(p.id).push(p);
          });

          const AHORA = Date.now();
          const datosFormateados = [];

          porId.forEach((lista) => {
            /* 1. recientes dentro de la ventana de tiempo */
            const recientes = lista.filter(
              (p) =>
                AHORA - p.timestamp * 1000 <= VENTANA_TIEMPO_SEGUNDOS * 1000
            );

            /* 2. si no hay recientes ⇒ tomar los  MAX_PUNTOS  últimos */
            const usados = recientes.length
              ? recientes.slice(-MAX_PUNTOS) // ← solo los 100 últimos recientes
              : lista.slice(-MAX_PUNTOS);

            usados.forEach((p) =>
              datosFormateados.push({
                id: p.id,
                lat: p.latitude,
                lon: p.longitude,
                alt: p.altitude,
                timestamp: p.timestamp,
                custom: p.custom,
              })
            );
          });

          /* Mantén el orden cronológico */
          datosFormateados.sort((a, b) => a.timestamp - b.timestamp);

          actualizarUsuariosDesdeAWS(datosFormateados);
        } catch (err) {
          console.error("Error al cargar posiciones desde AWS:", err);
        }
      }

      //
      // Función para actualizar el panel desplegable con los datos del punto
      function updatePointPanel(x, y, z, lat, lon, alt) {
        debug("Actualizando panel de puntos GPS...");

        try {
          const pointContent = document.getElementById("points-panel-content");

          // Convertir coordenadas decimales a formato DMS
          const latDMS = decimalToDMS(lat, true);
          const lonDMS = decimalToDMS(lon, false);

          function headingToCompass(deg) {
            if (deg === undefined || deg === null || deg < 0) return "—";
            const sectores = [
              "Norte", // 337.5° – 22.5°
              "Noreste", // 22.5° – 67.5°
              "Este", // 67.5° – 112.5°
              "Sureste", // 112.5° – 157.5°
              "Sur", // 157.5° – 202.5°
              "Suroeste", // 202.5° – 247.5°
              "Oeste", // 247.5° – 292.5°
              "Noroeste", // 292.5° – 337.5°
            ];
            // índice 0-7 según el ángulo
            const idx = Math.floor(((deg + 22.5) % 360) / 45);
            return sectores[idx];
          }

          const headingTxt = headingToCompass(user.custom?.heading);
          const speedTxt =
            user.custom?.speed !== undefined
              ? Number(user.custom.speed).toFixed(3) // 3 decimales
              : "—";

          // Crear o actualizar el contenido del panel
          pointContent.innerHTML = `
                    <div class="point-item" style="cursor: pointer;" title="Centrar cámara en este punto">
                        <div class="point-icon"></div>
                        <div class="point-details">
                            <div class="point-title">Posición GPS</div>
                            <div class="point-coords">
                                Lat: ${latDMS}<br>
                                Lon: ${lonDMS}<br>
                                Alt: ${alt.toFixed(2)} m<br>
                                Vel.: ${speedTxt} m/s<br>
                                Heading: ${headingTxt}<br>
                                <small>Nube: X=${x.toFixed(2)}, Y=${y.toFixed(
            2
          )}, Z=${z.toFixed(2)}</small>
                            </div>
                        </div>
                    </div>
                `;

          const pointItem = pointContent.querySelector(".point-item");
          pointItem.addEventListener("click", () => {
            debug("Panel clickeado, centrando cámara en punto GPS...");
            if (!cameraMoving) {
              moveCamera(x, y, z);
            } else {
              alert("La cámara ya se está moviendo. Por favor espere...");
            }
          });

          debug("Panel de puntos GPS actualizado");
        } catch (error) {
          debug(`ERROR al actualizar panel de puntos: ${error.message}`);
          console.error("Error al actualizar panel de puntos:", error);
        }
      }

      // Función para mover la cámara de forma suave con pasos intermedios
      function moveCamera(x, y, z) {
        if (!pointcloud || cameraMoving) return;

        debug(
          `Moviendo cámara hacia el punto (${x.toFixed(2)}, ${y.toFixed(
            2
          )}, ${z.toFixed(2)})...`
        );
        cameraMoving = true;

        try {
          const camera = viewer.scene.getActiveCamera();
          const currentPos = camera.position.clone();
          const currentTarget = viewer.scene.view.getPivot().clone();

          const newTarget = new THREE.Vector3(x, y, z);
          const direction = new THREE.Vector3()
            .subVectors(currentPos, currentTarget)
            .normalize();
          const distancia = 50;
          const newPos = new THREE.Vector3(
            x + direction.x * distancia,
            y + direction.y * distancia,
            z + direction.z * distancia + 20
          );

          const numSteps = 20;
          const duration = 2000;
          const stepInterval = duration / numSteps;
          let currentStep = 0;

          function moveStep() {
            if (currentStep >= numSteps) {
              cameraMoving = false;
              debug("Movimiento de cámara completado");
              if (pointcloud) {
                pointcloud.visible = true;

                const updateLOD = () => {
                  viewer.scene.dispatchEvent({ type: "pointclouds_loaded" });
                  viewer.scene.dispatchEvent({ type: "update" });
                };

                updateLOD();
                setTimeout(updateLOD, 500);
                setTimeout(updateLOD, 1000);
              }
              return;
            }

            const progress = (currentStep + 1) / numSteps;
            const lerpPos = new THREE.Vector3().lerpVectors(
              currentPos,
              newPos,
              progress
            );
            const lerpTarget = new THREE.Vector3().lerpVectors(
              currentTarget,
              newTarget,
              progress
            );

            viewer.scene.view.setView(
              [lerpPos.x, lerpPos.y, lerpPos.z],
              [lerpTarget.x, lerpTarget.y, lerpTarget.z]
            );

            if (pointcloud && !pointcloud.visible) {
              pointcloud.visible = true;
              debug(
                "Forzando visibilidad durante movimiento, paso " + currentStep
              );
            }

            currentStep++;
            setTimeout(moveStep, stepInterval);
          }

          moveStep();
        } catch (error) {
          cameraMoving = false;
          debug(`ERROR al mover la cámara: ${error.message}`);
          console.error("Error al mover la cámara:", error);
        }
      }

      //-----------------------------------------------------------------------------

      class GPSDatabase {
        constructor(tableName = "locations") {
          if (!window.awsConfig) {
            throw new Error("awsConfig no está definido.");
          }

          AWS.config.update({
            region: window.awsConfig.region,
            accessKeyId: window.awsConfig.accessKeyId,
            secretAccessKey: window.awsConfig.secretAccessKey,
          });

          this.tableName = tableName;
          this.docClient = new AWS.DynamoDB.DocumentClient();
        }

        //-----
        async getRecentPositions(count = 1500) {
          const params = {
            TableName: this.tableName,
          };

          const data = await this.docClient.scan(params).promise();
          const resultadosValidos = data.Items.filter(
            (item) =>
              typeof item.latitude === "number" &&
              typeof item.longitude === "number" &&
              typeof item.altitude === "number" &&
              typeof item.timestamp === "number"
          ).sort((a, b) => a.timestamp - b.timestamp); // Más antiguo → más reciente

          return resultadosValidos.slice(-count).map((item) => ({
            id: item.deviceId || "IDebugging", // ✔️ usa el ID real, o uno forzado si no está presente
            timestamp: item.timestamp,
            latitude: item.latitude,
            longitude: item.longitude,
            altitude: item.altitude,
            custom:
              typeof item.custom === "object" && item.custom !== null
                ? item.custom // p.ej. {heading:0, speed:0}
                : {}, // siempre devolver un objeto
          }));
        }

        //---
        validatePosition(item) {
          return (
            typeof item.timestamp === "number" &&
            typeof item.latitude === "number" &&
            typeof item.longitude === "number" &&
            typeof item.altitude === "number" &&
            typeof item.id === "string"
          );
        }
      }

      // Crear un marcador para el punto de referencia
      function createReferenceMarker() {
        if (!cloudLoaded) return;

        debug("Creando marcador para el punto de referencia...");

        try {
          // Crear un cubo para el punto de referencia
          const cubeGeometry = new THREE.BoxGeometry(3, 3, 3);
          const cubeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
          referenceMarker = new THREE.Mesh(cubeGeometry, cubeMaterial);

          // Colocar en el punto de referencia exacto
          referenceMarker.position.set(
            referencePoint.cloud.x,
            referencePoint.cloud.y,
            referencePoint.cloud.z
          );

          // Añadir a la escena
          viewer.scene.scene.add(referenceMarker);
          debug(
            "Marcador de referencia creado (cubo verde en aleta de tiburón)"
          );
        } catch (error) {
          debug(`ERROR al crear marcador de referencia: ${error.message}`);
          console.error("Error al crear marcador de referencia:", error);
        }
      }

      //-------------------------------------------------------------------------------

      viewer.loadGUI(() => {
        debug("GUI de Potree cargada");
        viewer.setLanguage("en");

        // Ocultar sidebar al inicio
        viewer.toggleSidebar();
        debug("Sidebar ocultada");

        // Ocultar todas las herramientas excepto las especificadas
        const toolsToKeep = ["full_extent"];

        // Recorrer todas las herramientas y ocultar las que no están en la lista
        for (let key in viewer.measuringTool) {
          if (!toolsToKeep.includes(key)) {
            try {
              viewer.measuringTool[key].element.style.display = "none";
            } catch (e) {
              debug(`No se pudo ocultar la herramienta: ${key}`);
            }
          }
        }

        // También intentar ocultar elementos del menú que no necesitamos
        setTimeout(() => {
          try {
            // Ocultar elementos de menú no necesarios
            document
              .querySelectorAll(
                "#potree_sidebar_container .potree_menu_buttons li"
              )
              .forEach((item) => {
                if (!item.classList.contains("full_extent")) {
                  item.style.display = "none";
                }
              });
            debug("Herramientas innecesarias ocultadas");
          } catch (e) {
            debug(`Error al ocultar elementos de menú: ${e.message}`);
          }
        }, 1000);

        // Ocultar completamente el sidebar de Potree
        document.getElementById("potree_sidebar_container").style.display =
          "none";
        debug("Panel lateral de Potree completamente ocultado");
      });

      //----------------------------------M1.1---------------------------------------------------

      Potree.loadPointCloud("pointclouds/Nube1/cloud.js", "Nube1", (e) => {
        debug("Cargando nube de puntos...");
        pointcloud = e.pointcloud;
        let material = pointcloud.material;
        viewer.scene.addPointCloud(pointcloud);

        debug("Nube de puntos añadida a la escena");

        // Determinar la altura mínima de la nube
        try {
          const boundingBox = pointcloud.boundingBox;
          minCloudHeight = boundingBox.min.z;
          debug(`Altura mínima de la nube detectada: ${minCloudHeight}`);
        } catch (error) {
          debug(`Error al determinar altura mínima: ${error.message}`);
          // Usar un valor predeterminado si no se puede determinar
          minCloudHeight = 0;
        }

        //-------------------------------------------------------------------------------

        debug("Nube de puntos añadida a la escena");

        // Configuración fija para la visualización de intensidad
        material.activeAttributeName = "intensity";
        material.size = 1;

        // MODIFICACIÓN: Reactivar renderizado adaptativo
        material.pointSizeType = Potree.PointSizeType.ADAPTIVE; // Cambiar de FIXED a ADAPTIVE
        material.shape = Potree.PointShape.SQUARE;

        // Configuración específica para la intensidad
        material.intensityRange = [0, 255];
        material.intensityGamma = 0.43;
        material.intensityBrightness = 0.03;
        material.intensityContrast = -0.06;

        // Ajustes de nivel de detalle (LOD) para optimizar la carga
        pointcloud.minNodeSize = 50; // Reduce de 100 a 50 para mayor detalle a distancia
        pointcloud.maxNodeSize = 300; // Tamaño máximo de nodo a cargar
        pointcloud.progressiveRendering = true; // Activar renderizado progresivo
        viewer.setPointBudget(2_000_000); // Volver a 2M puntos para equilibrar rendimiento

        debug("Configuración de visualización de intensidad aplicada");

        // MODIFICACIÓN: Forzar carga completa de la nube
        pointcloud.showBoundingBox = true; // Mostrar el cuadro delimitador
        pointcloud.generateDEM = false; // Desactivar generación DEM que podría afectar rendimiento

        viewer.fitToScreen();
        debug("Ajustando vista a pantalla completa");

        // Inicializar el administrador de anotaciones
        annotations = viewer.scene.annotations;
        debug("Administrador de anotaciones inicializado");

        // Marcar que la nube está cargada
        cloudLoaded = true;

        // Crear el marcador de referencia
        createReferenceMarker();

        try {
          gpsDB = new GPSDatabase("locations");
          debug("Base de datos AWS inicializada correctamente.");
        } catch (err) {
          console.error("Error al inicializar la base de datos AWS:", err);
          alert("No se pudo conectar con AWS. Verifica la consola.");
        }

        // Comenzar la escucha automática al servidor AWS
        setInterval(() => {
          cargarDesdeAWS();
        }, 10000); // cada 10 segundos

        // Usar la primera coordenada de la matriz como punto inicial
        for (const [id, user] of userLocations) {
          if (user.lat != null && user.lon != null && user.alt != null) {
            const cloud = convertGPSToCloudCoords(user.lat, user.lon, user.alt);
            if (!cloud) continue;
            const marker = createUserMarker(cloud.x, cloud.y, cloud.z, user);
            userMarkers[id] = marker;
          }
        }

        //

        // Buscar primer usuario activo para centrar cámara
        let firstAvailable = [...userLocations.values()].find(
          (user) => user.lat != null && user.lon != null && user.alt != null
        );

        if (firstAvailable) {
          const cloud = convertGPSToCloudCoords(
            firstAvailable.lat,
            firstAvailable.lon,
            firstAvailable.alt
          );
          if (cloud) {
            moveCamera(cloud.x, cloud.y, cloud.z);
            debug(`Cámara centrada sobre usuario activo ${firstAvailable.id}`);
          }
        } else {
          // Si nadie está activo, centrar sobre el punto de origen de la nube
          const origin = referencePoint.cloud;
          if (origin) {
            moveCamera(origin.x, origin.y, origin.z);
            debug("Cámara centrada sobre el punto de origen de la nube");
          }
        }

        // Centrar cámara en el primer usuario
        if (userLocations.length > 0) {
          const first = userLocations[0];
          const cloud = convertGPSToCloudCoords(
            first.lat,
            first.lon,
            first.alt
          );
          if (cloud) moveCamera(cloud.x, cloud.y, cloud.z);
        }

        //

        // Agregar manejadores de eventos para la nube
        pointcloud.addEventListener("visibility_changed", (e) => {
          debug(
            `Visibilidad de la nube cambiada: ${
              e.visible ? "visible" : "invisible"
            }`
          );

          // Si se vuelve invisible durante el renderizado adaptativo
          if (!e.visible && !cameraMoving) {
            setTimeout(() => {
              pointcloud.visible = true;
              debug("Restaurando visibilidad con renderizado adaptativo");

              // Ajustar temporalmente a menos puntos para recuperar visibilidad más rápido
              const currentBudget = viewer.getPointBudget();
              viewer.setPointBudget(Math.min(500000, currentBudget));

              // Restaurar presupuesto original después de recuperar visibilidad
              setTimeout(() => {
                viewer.setPointBudget(currentBudget);
                debug("Restaurando presupuesto de puntos original");
              }, 500);
            }, 100);
          }
        });
        //----------------------------------------------------------------------
      });

      // Variable para almacenar la altura mínima de la nube
      let minCloudHeight = null;

      viewer.addEventListener("update", function () {
        if (!cloudLoaded || !pointcloud) return;

        // Comprobar si la nube está visible
        const isVisible = pointcloud.visible;
        if (!isVisible) {
          debug("ADVERTENCIA: La nube de puntos no es visible actualmente");

          // Reintentar hacer visible la nube
          pointcloud.visible = true;
          viewer.scene.view.setPointCloudsVisible(true);
        }

        // Limitar la altura mínima de la cámara
        if (minCloudHeight !== null) {
          const camera = viewer.scene.getActiveCamera();
          if (camera && camera.position.z < minCloudHeight + 5) {
            debug(`Limitando cámara a altura mínima: ${minCloudHeight + 5}`);
            camera.position.z = minCloudHeight + 5;
            viewer.scene.view.update(
              viewer.scene.getActiveCamera(),
              viewer.scene.pointclouds
            );
          }
        }
      });

      // Funcionalidad adicional para ajustar la vista si hay problemas

      function resetView() {
        if (!cloudLoaded) {
          debug("No se puede reiniciar la vista - la nube no está cargada");
          return;
        }

        debug("Reiniciando vista de la nube...");

        try {
          // Forzar visibilidad
          if (pointcloud) {
            pointcloud.visible = true;
          }

          // Evitar error: primero desactivar cualquier animación pendiente
          if (cameraMoving) {
            cameraMoving = false;
            debug("Cancelando movimiento de cámara previo");
          }

          // Esperar un momento para asegurar que animaciones anteriores hayan terminado
          setTimeout(() => {
            try {
              // MODIFICACIÓN: Usar las coordenadas del marcador GPS si existe
              if (gpsMarker) {
                const pos = gpsMarker.position;
                debug(
                  `Centrando vista en marcador GPS (${pos.x.toFixed(
                    2
                  )}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})`
                );

                // Establecer vista desde una posición elevada mirando al marcador GPS
                const safePosition = [pos.x + 50, pos.y + 50, pos.z + 50];
                const targetPosition = [pos.x, pos.y, pos.z];

                viewer.scene.view.setView(safePosition, targetPosition);
              } else {
                // Si no hay marcador GPS, usar el punto de referencia como respaldo
                debug("No hay marcador GPS, usando punto de referencia");
                const safePosition = [
                  referencePoint.cloud.x + 50,
                  referencePoint.cloud.y + 50,
                  referencePoint.cloud.z + 50,
                ];
                const targetPosition = [
                  referencePoint.cloud.x,
                  referencePoint.cloud.y,
                  referencePoint.cloud.z,
                ];

                viewer.scene.view.setView(safePosition, targetPosition);
              }

              // Asegurar que todas las nubes de puntos estén visibles
              viewer.scene.view.setPointCloudsVisible(true);

              // Forzar una actualización del renderizado
              viewer.scene.dispatchEvent({ type: "update" });

              // Ajustar suavemente la vista después de un breve retraso
              setTimeout(() => {
                try {
                  // Forzar actualización
                  viewer.scene.dispatchEvent({ type: "update" });
                  viewer.scene.dispatchEvent({ type: "pointclouds_loaded" });

                  // Ejecutar la función de estabilización
                  stabilizeView();
                } catch (innerError) {
                  debug(`Error en resetView: ${innerError.message}`);
                }
              }, 500);
            } catch (delayedError) {
              debug(
                `Error durante el reinicio retrasado: ${delayedError.message}`
              );
            }
          }, 100);
        } catch (error) {
          debug(`ERROR al reiniciar vista: ${error.message}`);
          console.error("Error al reiniciar vista:", error);
        }
      }

      //-----------------------------------------------------------------------------

      // Función auxiliar para estabilizar la vista después de fitToScreen
      function stabilizeView() {
        if (!cloudLoaded || !pointcloud) return;

        // Restaurar visibilidad y forzar actualización
        pointcloud.visible = true;
        viewer.scene.view.setPointCloudsVisible(true);

        // Ciclo de actualización progresiva
        const updateSequence = [100, 300, 600];
        updateSequence.forEach((delay) => {
          setTimeout(() => {
            viewer.scene.dispatchEvent({ type: "update" });
            viewer.scene.dispatchEvent({ type: "pointclouds_loaded" });
            debug(`Actualización estabilizadora a ${delay}ms`);
          }, delay);
        });
      }

      // Agregar controlador para teclas de teclado (para debugging)
      document.addEventListener("keydown", function (event) {
        // Tecla 'R' para resetear la vista
        if (event.key === "r" || event.key === "R") {
          resetView();
        }
      });

      //-----------------------------M4------------------------------------

      // Función para verificar y recuperar la visibilidad de la nube
      function checkAndRestoreCloudVisibility() {
        if (!cloudLoaded || !pointcloud) return;

        if (!pointcloud.visible) {
          debug("Detectada pérdida de visibilidad - intentando recuperar");
          pointcloud.visible = true;
          viewer.scene.view.setPointCloudsVisible(true);

          // Forzar actualización de nivel de detalle
          viewer.scene.dispatchEvent({ type: "pointclouds_loaded" });

          // Ajustar la vista cerca del marcador actual si existe
          if (gpsMarker) {
            const pos = gpsMarker.position;
            debug(
              `Reposicionando cerca del marcador (${pos.x.toFixed(
                2
              )}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})`
            );

            // Usar una posición ligeramente diferente para forzar actualización
            viewer.scene.view.setView(
              [pos.x + 10, pos.y + 10, pos.z + 30],
              [pos.x, pos.y, pos.z]
            );
          } else {
            // Si no hay marcador, reset completo
            resetView();
          }
        }
      }

      // Verificar visibilidad cada 3 segundos
      setInterval(checkAndRestoreCloudVisibility, 3000);

      // Función para optimizar la carga inicial
      function optimizeInitialLoading() {
        if (!cloudLoaded || !pointcloud) return;

        debug("Optimizando carga inicial de la nube...");

        // Secuencia de carga progresiva
        const progressiveLoad = (budget, delay) => {
          setTimeout(() => {
            viewer.setPointBudget(budget);
            debug(
              `Incrementando presupuesto de puntos a ${budget.toLocaleString()}`
            );
            viewer.scene.dispatchEvent({ type: "update" });
          }, delay);
        };

        // Comenzar con pocos puntos y aumentar progresivamente
        viewer.setPointBudget(500000); // Inicio con pocos puntos
        progressiveLoad(1000000, 1000); // 1M después de 1 segundo
        progressiveLoad(1500000, 2000); // 1.5M después de 2 segundos
        progressiveLoad(2000000, 3000); // 2M después de 3 segundos
        progressiveLoad(2500000, 4000); // 2.5M después de 4 segundos
      }

      // Inicializar el panel desplegable
      document.addEventListener("DOMContentLoaded", function () {
        // Configurar el toggle del panel desplegable
        const toggleBtn = document.getElementById("toggle-panel");
        const pointsPanel = document.getElementById("points-panel");

        // Estado inicial: expandido
        let isPanelCollapsed = false;

        toggleBtn.addEventListener("click", function () {
          isPanelCollapsed = !isPanelCollapsed;

          if (isPanelCollapsed) {
            pointsPanel.classList.add("panel-collapsed");
            toggleBtn.textContent = "≫";
          } else {
            pointsPanel.classList.remove("panel-collapsed");
            toggleBtn.textContent = "≪";
          }

          debug(
            `Panel de puntos ${isPanelCollapsed ? "contraído" : "expandido"}`
          );
        });

        debug("Panel desplegable de puntos GPS inicializado");
      });

      // Llamar a la función de optimización después de cargar la nube
      // Añade esta línea al final del bloque donde se carga la nube de puntos (línea ~465)
      setTimeout(optimizeInitialLoading, 1000);

      //----------------------------

      // Configurar los botones del panel de control lateral
      document.getElementById("btn-move-5m").addEventListener("click", () => {
        if (!cloudLoaded) {
          debug("Nube no cargada. No se puede trazar trayectoria.");
          return;
        }

        /* ───────────── 1. Si ya hay líneas creadas ⇒ simple toggle de visibilidad */
        if (window.trayectoriasLineas.size > 0) {
          for (const linea of window.trayectoriasLineas.values()) {
            linea.visible = !linea.visible;
          }
          debug(
            "Trayectorias visibles: " +
              [...window.trayectoriasLineas.values()].filter((l) => l.visible)
                .length
          );
          viewer.scene.dispatchEvent({ type: "update" });
          return;
        }

        /* ───────────── 2. Crear las líneas a partir de los puntos almacenados  */
        let seCreoAlguna = false;

        for (const [id, trayectoria] of window.trayectoriasPorUsuario) {
          if (trayectoria.length < 2) continue; // necesita ≥2 puntos

          /* Cada elemento YA tiene x, y, z: no vuelvas a convertir */
          const puntos = trayectoria.map(
            (p) => new THREE.Vector3(p.x, p.y, p.z + 2)
          );

          /* Línea simple (BufferGeometry + Line)   ─ menos pesada y sin caras */
          const geometry = new THREE.BufferGeometry().setFromPoints(puntos);
          const color = new THREE.Color(
            userLocations.get(id)?.color || 0xffffff
          );
          const material = new THREE.LineBasicMaterial({ color });

          const linea = new THREE.Line(geometry, material);
          linea.name = `Trayectoria_${id}`;
          linea.visible = true;
          viewer.scene.scene.add(linea);

          window.trayectoriasLineas.set(id, linea);
          seCreoAlguna = true;
        }

        if (seCreoAlguna) {
          debug(
            "Trayectorias dibujadas para: " +
              [...window.trayectoriasLineas.keys()].join(", ")
          );
          viewer.scene.dispatchEvent({ type: "update" });
        } else {
          alert("No se encontraron trayectorias válidas.");
        }
      });

      // Añadir al final de la configuración de los botones del panel de control lateral (línea ~755)
      // Forzar carga específica del icono Full Extent
      const fullExtentIcon = document.querySelector(".potree_full_extent_icon");
      if (fullExtentIcon) {
        fullExtentIcon.style.backgroundImage =
          "url('./libs/potree/resources/icons/fit.svg')";
        debug("Icono Full Extent forzado");
      }

      //-------------------------------------
      // Función para asegurar que los iconos se cargan correctamente
      function ensureIconsLoaded() {
        const toolbarButtons = document.querySelectorAll(
          "#left-toolbar button i"
        );
        toolbarButtons.forEach((icon) => {
          // Forzar recarga del estilo del icono
          const computedStyle = window.getComputedStyle(icon);
          if (
            computedStyle.backgroundImage === "none" ||
            computedStyle.width === "0px"
          ) {
            // Recargar el icono aplicando nuevamente la clase
            const className = Array.from(icon.classList).find((cls) =>
              cls.includes("potree_")
            );
            if (className) {
              icon.classList.remove(className);
              setTimeout(() => icon.classList.add(className), 10);
            }
          }
        });
      }

      // Llamar a la función después de cargar la página y nuevamente después de un segundo
      document.addEventListener("DOMContentLoaded", function () {
        setTimeout(ensureIconsLoaded, 500);
        setTimeout(ensureIconsLoaded, 1500);
      });
    </script>
  </body>
</html>
